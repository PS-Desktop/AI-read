hi everyone and welcome to my course azure application gateway course
0:07
in the next few hours we are going to do a deep dive into the azure application gateway to understand how it actually
0:15
works and we will be looking at the different routing configurations you can do in the
0:21
application gateway like how can you host multiple sites and how you can do url routing or
0:28
path-based routing and when it comes to redirection you will learn how can you direct the
0:35
traffic to another listener or to another internal website or to an
0:41
external website then you will see how can you rewrite your url or request headers that are
0:48
passing through your application gateway and how you can use it as an internal load balancer
0:54
and how can you configure the auto scaling and zone redundancy for the application gateway
1:00
and when it comes to the application gateway security or probably i should call it ssl security you will learn how
1:07
can you implement the ssl termination for the application gateway and if you have more stringent security
1:15
requirements you are going to see how you can do an end-to-end ssl encryption
1:20
through the application gateway and how can you define your own ssl policies and
1:26
configure mutual authentications in the application gateway
1:32
and when it comes to kubernetes you will learn how can you configure the ingress controller for aeks
1:39
through two ways of deployment whether it's a green field or brown field
1:45
and definitely we cannot talk about the azure application gateway without having a separate topic to talk about the web
1:53
application firewall of the application gateway which is going to provide an
1:58
additional layer of security for your web applications monitoring is going to be a very
2:04
important topic that we are going to cover through this course primarily aiming to set up your
2:10
diagnostic settings and teach you what would be the key metrics that you need to keep an eye on to ensure that your
2:18
application gateway is working well and even better how you create an alert
2:23
rules so you can get notified if certain metrics have exceeded a specific
2:28
threshold and you are going to see how you can configure healthy probes to ensure the
2:34
backend health of your application gateway also we are going to see how you can
2:40
handle high traffic that are coming through your application gateway what are the different pricing model the
2:46
frontiers and some advanced topics like cookie affinity connection draining and
2:52
web sockets finally we are going to talk about the key configurations that you need to
2:58
understand for your application gateway primarily the infrastructure configurations to make sure that you
3:05
configure your vnet and subnet properly from the get go then we are going to talk about the
3:11
other configurations relative to the application gateway so briefly in the
3:16
next three hours we are going to dive deep into the azure application gateway and you will understand every topic in
3:24
the application gateway and you will be confident using the application gateway in a production workloads
3:30
also it's worth mentioning that this course is completely hands-on like there is no powerpoint
3:37
presentations throughout the course at all you will see me either using azure
3:43
portal or azure online documentation now let's get started and let's learn azure
3:49
application gateway together
What is Azure Application Gateway?
3:54
hi everyone my name is hassain awad and welcome to my course azure application
3:59
gateway before we get started let's talk a little bit about what is azure
4:05
application gateway so in the most simplest terms application gateway is just a load
4:12
balancer with traffic load balancer that allows you to route traffic to your web
4:17
applications and some of you might get surprised when you hear that application gateway is
4:24
considered to be a load balancer but you are actually going to get more surprised when you know that there are
4:30
other services that comes under azure load balancing services and there are
4:35
four azure load balancer azure front door
4:40
azure traffic manager and finally azure application gateway
4:46
all of these four services comes under azure load balancing services
4:52
anyway the traditional load balancers operate at transport layer which is layer 4
4:58
which is primarily using tcp and udp protocols to allow it to route traffic
5:04
based on source ip address and port to a destination ip address and port
5:11
and what's the difference in the application gateway it's able to make routing decisions based on additional
5:17
attributes on the http request like the path or request headers
5:23
and when you hear that the application gateway makes these routing decisions based on some attributes in the http
5:30
request you might get an assumption that the application gateway will have to operate
5:36
at a different layer which is absolutely true application gateway has to operate at
5:41
application layer which is layer 7 to allow it to interpret http requests to
5:47
make routing decisions based on these attributes now let's have a quick look at the
5:54
application gateway so the application gateway has multiple versions at a high level it
6:01
could be a standard version or a waf version waff stands for web application firewall
6:08
and then it will interact with the customers to accept the traffic from the customers and based on the routing
6:15
configurations that's been configured in the application gateway the application gateway is going to
6:21
route the traffic to the right back in the pool based on the attributes that's
6:26
been sent in the http request this is briefly what is azure
6:32
application gateway is about and as we have talked about different
6:38
azure load balancing services it's going to be useful for you to go through this web page to understand them in more
6:44
details and i'm going to put a link in the description box so briefly here it lists the four
6:51
different azure load balancing services that we have talked about azure front door
6:57
traffic manager application gateway and load balancer
7:03
and it has a little comparison across two different dimensions whether this service should be used for
7:08
regional or global purpose or what is the recommended traffic to be used whether it's http or non-http
7:17
traffic however the most important thing in this page is the reference architecture
7:23
examples where it lists different scenarios and what would be the best service to be used in this case
7:31
so i'm not going to go through them one by one but i'm gonna go through the application gateway scenarios to help
7:37
you understand in which cases or in which scenarios we should be using
7:42
application gateway the first scenario we have in here when you have a web application with
7:47
relational database and you want to provide a high availability architecture for your infrastructure and for your sql
7:54
server database in this case application gateway should be used
8:00
and the second scenario when you have a multi-tenant sas on azure and the two load balancer services you are going to
8:07
use are front door and application gateway so the front door is going to help you
8:13
to have load balancing across regions while application gateway is going to
8:18
route traffic internally within the application as we are going to see in more details
8:25
and the last scenario we have in here is multi-region load balancing so in this case you are going to use a
8:31
traffic manager and application gateway so you can have a high availability
8:36
architecture across regions and also have a resilient disaster recovery plan
8:43
and it's important to mention here these are not the only cases you should be using the application gateway for
8:50
these are just a few examples to help you understand it better and in the near future i'm planning to
8:57
create few courses for other azure load balancing services so it will give you a
9:02
more detailed information about all four azure load balancing services
9:07
however as you already know the primary focus of this course will be on azure
9:12
application gateway this was just a quick overview of what is azure application gateway and where
9:20
it sets in terms of azure load balancing services and from the next video we are going to
9:26
start creating our application gateway thanks for watching and we'll see you in
9:31
the next video hi everyone in this video we are going
How Azure Applicaiton Gateway Works?
9:36
to analyze and understand how the application gateway actually works
9:41
how the application gateway could listen to an incoming request coming from the user and then will be able to direct it
9:49
to the right back in the pool target so let's start from the beginning
9:54
when the user send the request to the application gateway let's say in this scenario we are going to use the public
10:02
ip address of the application gateway so the users are going to use the public
10:07
dns reserver in order to be able to get the public ip address of the application
10:13
gateway and in case you are using the private ip address for the application gateway to
10:20
use it as an internal load balancer then the internal users will be able to use a
10:25
custom dns resolver you have created in azure to be able to hit or resolve the
10:31
private ip address for your application gateway then we are going to have listeners
10:38
listeners simply are checking for a connection requests coming from the users and you could have either
10:44
http or https listener that's going to determine whether you prefer to have an
10:51
encrypted traffic or unencrypted traffic and we have already seen the back in the
10:57
pool before you can create one back in the pool with multiple targets also you
11:02
can create multiple back-end pools in your application gateway
11:07
and the magic here is how the application gateway knows the right back in the target that want to direct a
11:15
certain request to it and the application gateway will be able to do this by the assessed of the
11:21
routing rules so we are going to define a routing rule on a particular listener to direct the
11:28
traffic to a particular back-end pool and in order to maintain the second part
11:34
of the connection between the application gateway and the back-end pools the application gateway needs to
11:40
use http settings whether it's http or https
11:46
there are two scenarios we are going to talk about in here in future whether you prefer to have an encrypted
11:52
traffic between the application gateway and the in the pools or you are going to have an unencrypted traffic based on
12:00
your preference and you may have noticed here there is a firewall configuration which is a key
12:05
thing generally speaking the application gateway comes with two categories
12:10
whether it's a standard or wealth waff stands for web application firewall and there are two
12:17
versions under each of them version one and version two and if you have a choosing to go ahead
12:23
with the wealth version what's going to happen is that the application gateway is going to assess the incoming requests
12:31
to see if there is any security threats on those requests before it will start
12:36
applying the routing rules on those requests and before start to directing these requests to the backend targets
12:44
this is a way to protect your back in the targets or to use the application
12:49
gateway as a web application firewall or as a wealth and we are going to cover the wav
12:55
version of the application gateway in more details later also i want you to be aware of that
13:02
application gateway does some modifications to the http requests coming through the application gateway
13:09
by adding five additional headers to the requests and these are the five additional headers you just need to be
13:15
aware of them in case you are going to need them in future to do some tracing or diagnosing for any issues that might
13:22
happen between the application gateway and the backend targets that was a very high level overview of
13:30
how the application gateway works and in the next videos we are going to dive deep into each of these components to
13:37
understand how it actually works to direct the traffic to the back and the targets and we are going to see the
13:43
other options you could play around with that's all i have for you in this video
13:49
thanks for watching and i will see you in the next video
Important Note!!
13:55
hi everyone before we get started i just want to make sure it's clear for you that if you
14:01
are going to follow along with me and create all of these as your resources and components you should expect that
14:08
you are going to pay some money to azure at the end of the month in my case i have paid 100 australian
14:15
dollars at the end of the month when i was preparing my course and you could check and see what would
14:21
be the equivalent money that you will have to pay for different regions in azure
14:27
so if you are going to use your personal account just be prepared to pay some
14:32
money at the end of the month if you are not happy with that just don't go ahead and create any azure resources and just
14:39
watch my videos and it will give you a good understanding of the application gateway as well
14:45
however it's highly recommended for you to follow along with me and do what i am doing yourself
14:52
also i want to highlight how we are going to progress throughout the course so you are going to see me sometimes
14:59
create an application gateway for a specific scenario then delete it at the end of the scenario and then in the
15:05
second scenario maybe creating or provision another application gateway instance and we'll continue this till we
15:13
finish our scenario and then delete it at the end the reason i have done it that way
15:18
because it's going to be easier for you to understand how it works and i don't want to waste your time by reconfiguring
15:26
application gateway to change its configurations from a previous scenario to the new scenario
15:33
i found it's going to get us to the point really quickly by just deleting the old application gateway and create a
15:40
new one for the new scenarios just follow along with that and you will understand how it works and also in some
15:47
situations you might find me using the same application gateway instance
15:53
for multiple videos if we have a good use case for that just wanted to give
15:58
you a heads up about that so you won't be surprised during the course that's all i have for you for this video
16:05
thanks for watching now let's dive into the application gateway
Routing Introduction
16:12
hi everyone in this video or in this section we are going to talk about the different routing configurations in the
16:20
application gateway we will see how can we do the multiple site hosting
16:25
also the path based routing and different redirection mechanisms whether
16:30
redirection to another listener or an internal or external website
16:36
then we are going to see how the rewriting sets are working how can we rewrite the url or http
16:43
headers then we are going to see how can we use the application gateway as an internal load balancer and finally we
16:50
are going to see the auto scaling configurations and zone redundancy this
16:56
is just an introductory video to give you a head up about what's going to happen in the next few videos
17:02
let's dive straight into it thanks for watching and i'll see you in the next video
Create an Azure Application Gateway
17:09
hi everyone in this video we are going to go ahead and create our application gateway
17:15
and as you can see this is a brand new azure subscription doesn't have any resources in the subscription at all and
17:23
we are going to go ahead and create everything from scratch so the first thing we want to do here is
17:29
to create our resource groups
17:38
i'm going to create a resource group in australia east region i'm going to call it
17:45
stands for resource group and then the region
17:52
then i'm gonna create it in australia east region
17:58
and let's go ahead and create the resource group actually i'm going to go ahead and
18:03
create another resource group let's call it rg
18:08
australia east as well but we are going to call it v-net
18:17
and let's host it in australia east as well
18:28
now we have two resource groups then the next step we are gonna create a v-nets virtual networks
18:42
so i'm going to create a new v-net and put it in
18:47
v-net resource group i'm going to call it v-net
18:52
au east
19:00
and then leave everything to the default values and go ahead and create
19:05
the virtual network all right now let's go ahead and create our
19:11
application gateway let's
19:16
put it in australia east resource group and let's call it my application gateway
19:23
and put it in australia east region and there are different tiers of the application gateway as you can see
19:30
for now let's put it in the standard v2 tier no auto scaling and leave everything to
19:37
the default values and here for the virtual network we are
19:42
going to select v-net auest and then we need to put it in subnet
19:49
there is one interesting thing about application gateway that you need to be aware of it has to be placed in a subnet by
19:56
itself like you cannot have any other azure resources in the same subnets that
20:02
has an application gateway so probably it's going to be a good idea if i go back
20:08
to my azure vnet and create additional subnet for the application gateway so i'm going
20:15
to call it subnet application gateway and let's leave
20:21
everything to the default values and then go back to the application gateway
20:28
and select again the v-net again and select the subnet that i've created
20:34
for the application gateway now move to the front-end port
20:40
in here you are going to create a public ip address for the application gateway and as long as i don't have any public
20:47
ip address created in my subscription i will go ahead and create a new one
20:52
let's name it ip application gateway
20:59
let's call it public now
21:06
go to the next step where we are going to create a back-end pool for our application gateway
21:12
so let's create a back-end pool and
21:18
make this back in the pool without any target like its empty pool and we are going to add targets later on
21:27
now moving to the next page which is the configuration
21:33
we are going to add routing rules and the routing rules i'm gonna call it
21:41
traffic routing and the listener name we don't have any listeners yet we are going to call it
21:50
public ip listener and then the front ip address we are
21:56
going to use a public ip address we have created and leave everything to the default values
22:03
and for the backend targets we are going to select the back in the pool we have created and also for the http settings
22:10
let's go ahead and create one let's call it my http settings
22:18
and leave everything to the default values and edits
22:23
and now let's go ahead and add this routing rule then go to the next page
22:30
and go ahead and create the application gateway
22:36
and while we are waiting for the application gateway to be created let's go ahead and create virtual machines
22:42
which are going to be the back in the target for our application gateway so let's create a virtual machine
22:49
let's put in australia east resource group let's call it vm1
22:55
and let's select username and password and then
23:01
for the public inbound ports let's select none then going to the networking make sure
23:06
that we are selecting the v-net we have created before and in the default subnet
23:12
and leave everything else to the default values go ahead to review our configuration
23:21
and then let's go ahead and create the vm
23:26
as you can see here there is some coast will be added for you of course when we create a vm
23:32
again we will need to create another vm again we know the configuration that we need
23:38
to do so we are going to put it in australia east region we're going to call it vm2
23:44
select same username and password to make it easier for you to log to these machines
23:51
and then for the public inbound ports we are going to make it none going to the networking
23:57
we are going to make sure that we selected the v nets we have created before and then let's go ahead and create our
24:04
vm
24:10
so far we have created two virtual machines that we are going to use them as a back
24:16
in the targets for our application gateway and in order to be able to test it we
24:22
will need to install iis on the virtual machines and also have a test html page
24:28
that are going to be display the name of the virtual machine so let's go ahead and create or install
24:35
iis on the virtual machines and there are two ways you are able to do this whether you create a bastion
24:43
host subnet and then log into the vm and install iis yourself
24:50
or you can just run a small script in azure powershell here so let's click on
24:55
this link here as you can see here i don't have any storage account for my cloud chill so let's go ahead and create
25:02
one now i'm going to go ahead and copy and paste the command i have prepared before
25:09
to just make it easier for us to install iis on our machine so we are going to specify our resource group
25:15
iis here needs to be installed and the name of the vm and then of course the location of my vm
25:24
let's go ahead with that by the way i'm going to put this command
25:30
in the description box so you can use it
25:36
now we have installed iis and at html page for testing on our first vm
25:43
and let's do exactly the same on the second vm and the only thing i will need to change here is the vm name instead of
25:50
one i'm gonna make it vm2 let's go ahead with that
25:56
great now the iis has been installed on the second vm as well now let's go back to the application
26:02
gateway and let's browse to the backend pools
26:09
if you remember when we created the back in the pools we didn't assign any target
26:14
to the backend pools because we didn't have any vms ready at that point
26:21
so we are going to go ahead and add backend pools so we are going to add the vms make the
26:27
target vm1 and then we add another vm let's make it vm2
26:35
and let's go ahead and save our changes
26:40
now let's go ahead and test the application gateway so let's go to overview and copy the
26:47
public ip address for the application gateway and let's put it in the browser
26:56
so as you can see here it shows vm1 because the application gateway in this case
27:02
acts as a load balancer between vm1 and vm2 because both of these vms sets in
27:09
the same back-end pool so if we are going to refresh this page sometimes you are going to see vm2
27:16
vm1 vm2 vm1 again this is just to prove or show you how we can use the
27:22
application gateway to route traffic to different back-end resources that set in
27:28
a back-end pool so this was just a quick video to show
27:34
you how you create the application gateway and assign backend resources to it
27:39
now we are going to clean up the resources we have created so let's go to
27:44
australia east resource group and this will have all of the resources we have created for the vms and the application
27:51
gateway and let's go ahead and delete the resource group all together
28:02
so this is the end of this video i hope you enjoyed it and i'm gonna see you in the next video
28:08
thanks for watching hi everyone
Host Multiple-Sites
28:13
in this video we are going to see how we use the application gateway to host multiple sites
28:20
so we are going to have two separate websites like contoso.com and
28:25
fabricam.com and then by using the application gateway we are going to route traffic
28:31
from each of these websites to the right back in the pool definitely by using the routing
28:37
configurations in the application gateway let's get started and see how can we do
28:43
this but first let me go ahead and create a new resource group
28:55
and let's call it australia east resource group as well
29:01
and put it in australia east region let's go ahead and create it
29:07
now let's go ahead and create an application gateway
29:13
and let's put it in australia east resource group let's call it my application gateway
29:19
unhosted in australia east region standard version 2 no auto scaling and
29:25
then let's put it in the virtual network that we have created before and in the subnet
29:31
that we have created for the application gateways if you remember now let's go ahead to the next step
29:39
and let's go ahead and create a public ip address let's call it ip
29:46
my application gateway and then let's go to the next step
29:53
now let's go ahead and add the back in the pool and we'll add two back in the pools the first one we will call it
30:00
contoso pool and since we don't have any vms ready
30:06
yet we are going to have empty pool like doesn't have any targets
30:14
and then we are going to add another pool and let's call it fabricam
30:20
and same as before it's not going to have any targets yet
30:26
now let's go to the next step as you can see here we have created the front-end ip address
30:33
and we have back in the pools what needs to be created now is the routing rules
30:40
so let's go ahead and add routing rules so we are going to add a contoso
30:45
rule and we will create a listener as well call it contoso listener contempt ip address is
30:52
going to be public and here for the listener type we are going to have multi sites
30:58
that's again allow us to host multiple sites to the application gateway and then let's put contoso.com
31:06
and then for the back in the targets let's select contoso pool and since we don't have any http
31:13
settings let's go ahead and create one let's call it my http settings
31:20
leave everything to the default values and then let's go ahead and add this
31:26
routing rule and let's go ahead and create a new one
31:31
for the fabricam website so we are going to call this role
31:36
fabricam rule and then the listener name
31:43
african listener as well front end ip address is going to be public that we have created before and
31:50
for the listener type we are going to have multi site and then the host name we are going to
31:56
put fabrikam.com and the bet for the back in the targets
32:02
let's select fabric and pool and the http settings that we have created before
32:08
let's go ahead and add this routing rule as well now let's go to the next step
32:13
and create our application gateway
32:20
now while my application gateway is ready for me let's go ahead and create two vms
32:26
for one for contoso vm and the other one for fabricam to help us test this
32:32
configurations so let's go to virtual machines
32:41
let's create a new virtual machine let's put it in australia east resource
32:47
group let's call it contoso vm australia east region
32:54
let's select a username and password and for the public inbound ports let's
33:01
select none then moving to the networking and put
33:06
the vm in the vnet that we have created before
33:12
and then let's go ahead and create our vm
33:22
now let's go ahead and create fabric and vm
33:30
and we are going to put it in australia east resource group call it fabricam vm
33:37
then select a username and password and for the public inbound ports let's
33:43
select none moving to the networking let's put our vm in the vnet that we have created
33:50
before in the default subnet and let's go ahead and create our vm our
33:56
fabrikam vm
34:02
now my contoso vm is ready let's now open the cloud shell and run
34:07
our script that we have run in the previous video to install the iis with a test page on contoso vm
34:19
so our source group is rg australia east installing iis the vm name in this case
34:25
is going to be contoso vm and then everything
34:31
will be right now let's go to the second vm as well and open another cloud shell terminal
34:38
and run the same script we install iis and a sample or a test tool page on
34:44
fabric and vm as well so let's paste our command
34:52
and change the vm name to the fabricant
35:05
right now iis has been installed on contoso vm as well as fabricam vm
35:14
now let's go back to the application gateway it's been created
35:20
now go to the my application gateway going to the back in the pools i'm now going to change the back in the targets
35:27
for all of these backend pools so i'm gonna go to contoso pool and make my back in the target
35:35
to be contoso vm and similar to the fabricam pool as well
35:42
i'm going to make the back in the target to be fabric and vm
35:51
all right now let's go ahead and test and copy the public ip address of our
35:57
application gateway as you can see here nothing is found
36:02
and if i'm gonna go ahead and put contoso for example it's going to open contoso website for
36:09
microsoft it didn't direct the traffic to contoso vm that i have created right
36:16
this is because we have missed one important step updating the hostess file in the etc
36:22
folder as we have created the right routing configurations in the application
36:28
gateway it's very important to update the hosts file with the ip address of
36:34
the application gateway and contoso.com and fabricam.com
36:39
so let's go ahead and do this so here i have added two lines in my
36:45
hosts file with the contoso.com and fabrikam.com as well as the public ip address for the
36:52
application gateway let's save our changes and close the hostess file
37:00
and let's try put contoso again as you can see still it's not working
37:07
because we need to update or refresh the dns configurations so let's go ahead and
37:13
open the windows powershell ipconfig
37:18
register dns and then to see the dns whether the dns
37:26
configurations has took place or not let's type ipf ipconfig slash
37:32
display dns and if you scroll up you are going to
37:38
see the configurations you have put for contoso.com here the host or ip address
37:43
reflects to the ip address of the application gateway same for fabricam.com as well
37:51
so let's get back to my browser and try to type contoso.com and as you can see still it doesn't
37:58
direct the traffic to my vms so let's open a new
38:04
incognito window because we might have some browsing cache that doesn't
38:09
uh work well so let's open contoso as you can see now it routes the traffic to
38:15
our contoso vm that we have created now let's go ahead and type fabricam.com
38:22
again it will open or route the traffic to fabric and vm that we have created
38:29
so what we have done so far is we had created two separate backend pools
38:34
and by using the routing configurations in the application gateway we directed the traffic or route the traffic
38:41
from two different websites to the right back in the pool according to our configurations that we have placed in
38:48
the application gateway now let's go ahead and clean things up
38:56
now coming back to my azure portal let's go ahead and browse
39:02
to my resource groups and let's delete australia east resource
39:09
group with all of the resources we have created quantus ovm and all of the other resources the desk and ip address
39:16
network interface similar to fabric and vm and the application gateway as well
39:25
let's go ahead and delete that and also don't forget clean up the hostess file
39:33
and remove these two lines that we have entered
39:39
and then save your changes that's all i have for you for this video
39:46
i hope you enjoyed it and i will see you in the next video thanks for watching
URL Routing / Path-Based Routing
39:52
hi everyone in this video we are going to see how can we do url based routing
39:58
in the application gateway and the scenarios that we have for this video we are going to create an
40:04
application gateway then we are going to create a three different back in the pools
40:11
one general purpose back in the pool then you are going to have images back in the pool and finally video back in
40:18
the pool and based on the url that we are going to put in the address bar the
40:25
application gateway is going to direct the traffic to the right pool to the right backend pool
40:31
so when we put just the ip address of our application gateway then the application gateway is going to
40:38
route the traffic to the general purpose back in the pool however when we put images in the url
40:45
then our application gateway is going to direct the traffic to images back in the pool
40:51
and similarly for the video back in the poll as well this explains what i said earlier that
40:58
application gateway operates at layer seven this is going to allow our application
41:04
gateway to make routing decisions based on http attributes like the url in this
41:10
case now let's go ahead and see how can we do this
41:16
now let's go ahead and create a resource group
41:22
let's call it australia east resource group and put it in australia east region
41:33
now let's go ahead and create an application gateway
41:38
let's put it in australia east resource group let's call it my application gateway
41:44
and host it in australia east region standard version 2 no way no auto scaling is required and
41:51
then let's put it in the vnet that we have created before and the subnet that we have created for
41:57
the application gateway now let's go to the next tab
42:03
and let's create a new public ip address for our application gateway let's call
42:08
it ip my application gateway and then let's go to the next step here
42:15
we are going to create three different backend pools one we are gonna call it general
42:21
back and pool and since we don't have any vms yet let's
42:28
make this empty pool and then you are gonna add images back in the pool
42:37
again no targets and finally let's add video
42:44
back in the pool and again no targets
42:51
now let's go to the next step as you can see here we have configured the front-end ip for our application
42:58
gateway and we have configured the back in the pools as well what's missing here is to configure the routing rules
43:05
so let's go ahead and do it so let's call it routing rule
43:13
and let's create a listener for the front-end ip let's select the
43:18
public ip address of our application gateway and then for the back in the targets
43:24
let's select general back in the pool and for the http settings let's go ahead and create one
43:31
i'm going to call it my http settings and leave everything to the default
43:38
values what i'm going to do different in here is to add multiple targets to create a
43:44
path-based rule so i'm going to make images path in here
43:50
call it images and i'm going to use the http settings that i just created and the back in the
43:58
target in this case is going to be the back end pool the images back in the pool
44:03
let's go ahead and add this rule and i'm going to add another one for videos so i'm going to put video
44:12
slash astrix i'm going to call it video and then
44:18
use the http settings we have created and the back and the target is going to
44:23
be the video back in the pool let's go ahead and add this let's go ahead and add the routing rule
44:32
now let's go ahead and create the application gateway
44:38
and while it's been created let's go ahead and create three different vms one
44:44
that's gonna be used for general purpose and one is going to be used for the images and the other one is going to be
44:50
used for the videos now let's go ahead and create our
44:57
general virtual machine let's put it in australia east resource group let's call it general vm
45:07
let's put a username and password
45:14
and for the public inbound ports let's select none then let's go to the networking and
45:19
select the v-net that we have created before and the default subnet
45:24
let's go ahead and create the general vm
45:33
also let's go ahead and create images vm again let's put it on australia east region let's call it images vm
45:42
let's see select username and password and no inbound ports
45:49
and for the networking let's select the v-net that we have created and the default subnet
45:55
let's go ahead and create images vm
46:01
finally let's create videos vm put it in australia east resource group
46:08
let's call it video vm let's put a username and password
46:14
and no inbound ports for the networking let's put it in
46:20
the v-net that we have created before and the default subnet let's go ahead and create the video vm
46:35
now all vms have been created for me so let's go to the first one and open a new cloud shell let's run a script that i'm
46:42
going to put in the description box that is going to install iis and prepare the vm for the testing scenario that you are
46:49
building
46:58
and let's do the same thing on the second vm as well let's open another cloud shell terminal
47:05
and let's put the script but here i will need to change the vm name
47:11
to be images vm let's go ahead with that
47:18
and also let's go to the third tab and open another cloud shell and let's install
47:24
the iis on the videos vm as well
47:30
let's paste our script and again let's change the vm
47:36
name we would use vm let's go ahead with that
47:45
now we have iis installed on the three vms now let's go back to our application
47:51
gateway and update the back in the targets
47:59
so for the general back in the pool let's select a virtual machine let's make a general vm
48:07
and for the images back in the pool let's select images vm
48:15
and for the video back in the pool let's select video
48:20
vm all right
48:26
now let's go ahead and test our application gateway and let's copy the ip address
48:35
in this case it will get directed to general vm because we don't have any specific things in the url
48:42
however if i'm gonna put images slash test dot
48:49
htm it's going to get directed to images vm as you are able to see because we have
48:55
defined our path based routing based on the url
49:00
string and same thing if i'm gonna put video in the url it will get directed to the
49:06
video vm that's all i have for you for this video now let's go ahead and clean things up
49:14
so let's go to the resource group and let's select australia east resource
49:19
group and let's delete our resource group
49:33
right thanks everyone for watching and we'll see you in the next video
Redirection
49:40
hi everyone in this video we are going to see how we can do a traffic redirection through our
49:45
application gateway and the first scenario we are going to see is how we can redirect internal traffic through
49:52
our application gateway let's get started now let's go ahead and create a resource
49:58
group let's call it australia east resource
50:03
group and again put it in australia east region
50:10
now let's go ahead and create our application gateway and you've already known the steps
50:15
let's put in australia east resource group call it my application gateway put it in
50:23
australia east region standard version 2 no auto scaling put it in the v net we
50:29
have created before and the subnet for application gateway now let's go ahead and create a public
50:36
ip address
50:42
and for the back in the pool let's create two back-end pools the first one let's call it contoso pool
50:48
again no targets at the moment let's go ahead and edit and then let's
50:54
add fabric and pool as well and no target
51:02
now let's go to the configuration tab let's go ahead and add a routing rule let's call it contoso routing
51:12
and then contoso listener public ip address of the application
51:18
gateway and then for the back end the target let's select contoso pool and let's
51:24
create http settings
51:29
let's go ahead and add that let's go ahead and add the routing rule
51:34
let's add another routing rule for fabrikam
51:40
and let's call it fabricam listener and again listens to the public ip
51:45
address of the application gateway and you see here error because
51:51
it's a basic listener and has the same portal number of the previous routing rule or previous
51:57
listener that we have created so what we need to do here is to create a multi-site
52:02
and you have seen this already in multi-site hosting in the application gateway if you remember
52:08
let's call it fabricam dot com
52:14
and then going to the back end of the targets let's select fabricam pool and select the http settings we have created
52:23
before before we go away let's go back to the contoso listener and select
52:28
multi-site again and type in contoso.com
52:35
now let's go ahead and create our application gateway
52:40
while it's been created let's create two vms one for contoso.com and another one for
52:46
fabricam.com
52:54
let's put it in australia east resource group let's call it contoso vm and again let's put a username and
53:01
password no inbound ports and let's put it in the vnet we have
53:07
created before in the default subnet let's go ahead and create contoso vm
53:18
let's do the same for the other vm and create fabric and vm as well
53:32
australia east resource group let's call it fabricamvm
53:39
select a username and password no inbound ports
53:44
and put it in the v-net we have created before in the default subnets let's go ahead and create fabry cam vm
53:52
as well
54:02
now the two vms are ready for me let's go ahead and open a cloud shell terminal for both of them
54:13
and let's use our command that we have used before to install iis on the vms
54:20
checking the resource group in here
54:26
and our contoso vm let's go ahead with that
54:31
and let's do the same for fabric and vm as well
54:40
make sure that our resource group name is correct
54:47
and put in fabric and vm let's go ahead with that
54:55
now the iis has been installed on both vms now let's go ahead and edit my hosts
55:01
file let's put the public ip address of my
55:07
application gateway and contoso and fabricam websites
55:17
now let's go to my application gateway and let's update the backend pool and
55:23
assign targets for each pool so for contoso back in the pool i'm going to put contoso vm
55:30
and for fabricam back in the pool i'm going to assign fabricam vm
55:37
let's go ahead and save our changes and while we are doing this let's
55:44
update our dns
55:49
and while we are doing this let's update the dns
55:54
let's open windows powershell and run the command ib
56:00
config register dns
56:09
now the deployment has been succeeded let's go ahead and open incognit window and try to type
56:15
in contoso.com as you can see it gets redirected to contoso vm
56:21
let's open another tab for
56:28
fabrikam.com as you can see it directs the traffic to fabric and vm this is
56:34
exactly what we have been done before in multi-site hosting for the application gateway if you remember but what we are
56:40
going to do different in here is to redirect the traffic that coming from
56:46
fabricam.com to direct users to contoso.com and we are going to see how we can do
56:52
this let's go back to our application gateway let's go to the routing rules and let's
56:59
go to fabricam rule and for the back and the targets here we are going to make a redirection
57:06
let's again make it permanent temporary found or see other we are going to see what are the differences between all of
57:12
these a little bit later let's make it permanent and the listener here it's going to be directed or
57:19
redirected to contoso listener so when the users hit
57:24
fabricam listener it's going to be redirected to contoso listener
57:29
let's save our changes now let's go back to incognito to test
57:35
our changes when the user type in contoso.com it
57:41
will direct the user to contoso vm as usual but when the user try to hit
57:47
fabricam.com they will be redirected to contoso vm
57:53
this is exactly what we have been done recently we have created a redirection role to redirect the traffic coming from
58:00
one listener to another listener within the application gateway this is just one example or one scenario
58:07
of traffic redirection within the application gateway
58:12
now let's see another scenario let's go ahead and get back to our application gateway and go to fabrikam
58:19
rule and for the target type of the backend targets let's make it redirection as it
58:26
is but it change it to external site and let's put it in http
58:33
google.com and let's go ahead and save our changes
58:38
and let's see how this is going to change our redirection strategy for our application
58:44
gateway
58:50
let's open incognito and test it again when we hit contoso.com
58:56
it gets redirected to contoso vm and when we hit fabricam.com
59:04
it will get redirected to google.com as we have specified in our routing rule so
59:10
this is another scenario when you want to achieve or implement an external routing through your
59:16
application gateway now we are coming to the last
59:21
traffic redirection scenario we are going to do in this video and what we are going to do now is to how we can
59:28
redirect http traffic to https and in order to do this i need to go
59:34
ahead and create a self-signed certificate so let's open windows powershell and
59:39
let's run this command that i'm going to leave in the description box
59:48
and then let's go ahead and create a certificate
59:54
so what i'm going to do now is to change the thumbprint that we have got from the first command
1:00:00
and put it in the second script we have in here so now we have created a self-designed
1:00:06
certificate for contoso.com let's go to our application gateway and create https listener with this
1:00:14
certificate so let's go to the application gateway let's go to listeners and add https
1:00:22
listener let's assign it to the front-end ip
1:00:29
address make it https and let's select the self-assigned certificate that we've
1:00:35
just created and for the listener type let's make it multi-site and for the host name
1:00:41
let's put contoso.com and let's go ahead and add this listener
1:00:49
now let's go back to the routing rules and open fabrikam rule and change the
1:00:57
redirection listener to be https listener
1:01:03
i'm going to contuso routing rule and change the listener to be https
1:01:09
listener as well let's go ahead and save our changes
1:01:14
now let's go ahead and test it let's open a new browser tab
1:01:20
type in http fabriccam.com
1:01:27
so this is to show you how the application gateway was able to listen to http traffic
1:01:33
and then according to the routing configurations and redirection rules we have put in our application gateway
1:01:39
our application gateway has been able to view or redirect the http traffic into
1:01:45
https traffic and while we are here it's important to
1:01:51
have a look at this web page that lists the different types of redirections we have seen in the application gateway if
1:01:58
you remember we have seen four types of redirections permanent temporary found or see other so these are the different
1:02:05
http response codes for each of these types and i'm going to put a link for this
1:02:11
webpage in the description box as well this is all i have for you for traffic
1:02:16
redirection into the application gateway now let's go ahead and clean things up
1:02:22
so let's go to our resource group and let's delete our resource group
1:02:36
thanks for watching and we'll see you in the next video
Rewriting Sets
1:02:41
hi everyone in this video we are going to see how we can do rewriting sets in
1:02:47
our application gateway but firstly let's talk a little bit about why do we
1:02:52
need to do this why do we need to rewrite the http request response whether the url or the
1:02:59
http headers actually there are many reasons or many scenarios you want to do this
1:03:05
first of all is security maybe you want to provide an additional security to your back and the targets by
1:03:12
not exposing the end points of the back in the targets to the user or maybe you want to provide additional
1:03:19
parameters query string parameters into the url based on the user location that
1:03:25
is connecting to the application gateway there are so many scenarios and so many
1:03:30
cases you want to use the rewriting set into the application gateway
1:03:36
so let's go ahead and see how can we do this so let's go down to rewrites and create
1:03:42
a rewrite set let's call it my rewrite set
1:03:47
and let's select the internal role that we have created before let's go to the next page
1:03:54
now let's go ahead and add rewrite rule and let's add a condition
1:03:59
and our condition will be based on a server variable which is going to be the uri
1:04:06
request uri case sensitive know whether it's not equal to default
1:04:13
and then the action is going to be a url we are going to set a new url for both
1:04:21
path and query string parameters so we're going to have values
1:04:26
in the path also we are going to have some parameters like id equal one
1:04:33
and name equals john and then let's go ahead and create this
1:04:40
rewrite set and in order to be able to tell whether
1:04:46
this rewrite set takes a place or not i will have to create a log analytics workspace and create our diagnostic
1:04:53
settings for the application gateway and then i will be able to see the uri changes in the logs in my log analytics
1:05:01
workspace so let's go ahead and create a new log analytics workspace
1:05:06
you don't have to do this step
1:05:13
let's put it in australia east resource group let's call it log analytics
1:05:20
application gateway and let's put it in australia east region
1:05:26
and let's create vlog analytics workspace
1:05:31
now let's go back to my application gateway and create diagnostic settings
1:05:37
let's add diagnostic settings let's call it my diagnostic settings
1:05:44
and in here you will be able to choose what are the category groups you want to send to the log analytics workspace
1:05:51
and i'm going to choose all logs and all metrics and i'm going to send it to a log analytics workspace
1:05:58
as you can see in front of us here and let's go ahead and save our changes
1:06:05
now let's go to the logs to see how we will be able to test our changes and
1:06:11
let's run errors by uri query i'm gonna adjust it a little bit
1:06:16
and take off these parts
1:06:21
let's run the query one more time let's scroll a little bit to the right you will be able to see in the request to
1:06:27
your eyes some of the requests to your eyes has been updated with the rewrite set that we have created
1:06:34
and also if we scroll a little bit more to the right you will be able to see the id and name equal john that we have
1:06:40
created in some requests
1:06:47
so this is just to show you how we can use rewriting sets in the application gateway
1:06:52
however i'm gonna show you another link i'm gonna put it in the description box as well
1:06:58
that has different rewrite scenarios for http headers and url in the application
1:07:04
gateway i'm not going to implement everything in this web page but it's good to keep it for your reference to be
1:07:11
aware of what are the most common rewrite scenarios that people are doing in the application gateway
1:07:17
that's all i have for you in this video however i'm not going to delete the application gateway because i'm gonna
1:07:23
need it for the next video where we are gonna talk about the auto scaling and zone redundancy
1:07:29
thanks for watching and we'll see you in the next video
Internal Load Balancer (ILB)
1:07:35
hi everyone in this video we are going to see how we can use application gateway as an internal load balancer
1:07:43
and to be able to achieve this we primarily are going to use the private ip address of our application gateway so
1:07:50
it will allow it to direct traffic internally across multiple vms
1:07:55
let's get started and see how can we do this let's create a new resource group
1:08:00
let's call it australia east resource group
1:08:06
and let's put it in australia east region and let's create it
1:08:12
now let's create our application gateway let's put it in australia east resource
1:08:18
group and call it my application gateway
1:08:23
put it in australia east region standard version 2 no auto scaling is required
1:08:29
and then let's put it in the v-net we have created before and in the application subnet that we have created
1:08:38
now let's go to the next step and here is the key difference here we used to use the public ip address only
1:08:45
for our application gateway however in this case we are going to use a private ip address as well
1:08:52
keep in mind that if you are going to use a private ip address only for your application gateway you will have to use
1:08:58
the standard the tier of your application gateway and what i'm going to do now is to use
1:09:03
both public ip address and private ip address let's go ahead and create a public ip
1:09:09
address and then let's assign
1:09:15
a private ip address for our application gateway
1:09:21
keep in mind that this private ip address has to be in the subnet that you have created your application gateway in
1:09:30
and if you put something completely random you are going to get some hints from microsoft to tell you what is the
1:09:36
right subnet that you need to be using now let's go to the next step let's add
1:09:43
a back in the pool let's call it my back end pool
1:09:49
without no target and let's go ahead and add our configuration
1:09:54
let's create a routing rule let's call it internal routing
1:10:00
internal rule let's call it internal listener
1:10:05
and then for the front-end ip address i'm going to choose the private ip address so i'm
1:10:11
creating a listener to listen to the traffic on the private ip address
1:10:16
and then let's go to the back in the targets and let's select our backend pool and let's select or create a new http
1:10:24
settings let's call it my http settings
1:10:29
and let's go ahead and create our routing rule
1:10:37
now let's go ahead and create our application gateway
1:10:43
while it's been created let's go ahead and create two vms
1:10:54
so let's create a virtual machine put it in australia east resource group let's call it my vm1
1:11:01
let's select a username and password and no
1:11:07
inbound ports and then for the networking let's put it in the v-net we have created before and in the default
1:11:14
subnet let's create our vm
1:11:27
now i'm going to go ahead and create another vm
1:11:33
similar as before put it in australia east resource group call it vm2
1:11:38
put a username and password
1:11:44
and no inbound ports and for the networking let's put it in the v-net
1:11:49
that we have created before and in the default subnet let's go ahead and create it
1:11:57
actually i'm going to create a third vm so i'm going to test the internal load balancing part from it so let's go ahead
1:12:03
and create a third vm
1:12:12
and put it in australia's resource group and i'm going to call it test vm
1:12:17
let's put a username and password
1:12:23
no inbound ports or probably we need to leave the inbound ports for this vm to allow me to log to the vm remotely
1:12:30
however if you have a bastion host already for your subnet or for the your urvnet you can use it straight away but
1:12:37
i'm not going to create a new bastion subnet because it's going to cost you more money so i'm going to stick
1:12:43
to allow incoming ports for rdp to allow me to log into my vm and perform my testing however you
1:12:51
should never do this in production environment now going to the networking i'm going to
1:12:56
put it in the vnet we have created and the default subnet and let's go
1:13:02
ahead and create our test vm
1:13:12
now let's get back to our first vm and let's open a cloud shell to install iis
1:13:18
on our vm using the script we have used before in the description box
1:13:26
so let's paste our command here and
1:13:31
let's go ahead with that and similarly for the vm2 let's open a cloud chill
1:13:37
and install iis on the second vm on vm2 however we don't need to do this on the
1:13:44
test vm because we are going to log remotely into test vm
1:13:49
let's paste our command let's change the vm name to be vm2
1:13:56
let's go ahead with that now i have iis installed on both
1:14:02
vms so let's go to my application gateway and update the back in the pool targets
1:14:12
and let's select the virtual machine select the vm1 and another virtual machine vm two
1:14:19
and let's go ahead and save our changes now just to prove my point
1:14:25
that we haven't configured a listener on the public ip address of our application gateway let's go
1:14:32
ahead and try to paying the public ip address and see what we are going to get
1:14:39
and as you can see it didn't give us anything however you should be able to direct it to any other traffic you want by
1:14:47
creating a listener on the public ip address so you can have both public ip address and private ip address on the
1:14:54
same application gateway now let's go ahead and go to our test vm
1:15:00
and connect to it using rdp to test the internal load balancing of
1:15:06
our application gateway let's put it in my username and password
1:15:13
i've created for the vm and let's log it to the vm
1:15:21
now let's go to my local server
1:15:27
and change ie enhanced security configuration to be off
1:15:34
just help me to do my testing now let's get back to my application
1:15:40
gateway and copy the private ip address of my application gateway
1:15:45
let's get back to my test vm let's open internet explorer let's put the private ip
1:15:53
address of my application gateway as you can see it directs the traffic to
1:16:00
vm1 and as i refresh the page you are able to see that sometimes it gets a vm1
1:16:05
sometimes gets a vm2 this is to show you how we can use the application gateway
1:16:10
as an internal load balancer and however you can achieve both having the application gateway works as an
1:16:18
internal load balancer using the private ip address of the application gateway at the same time you can use it as a public
1:16:25
load balancer by using the public ip address of the application gateway
1:16:31
that's all i have for you for this video and i'm not going to delete the resources in this video because i'm
1:16:37
going to use the current application gateway we have created in the next video to show you how we can use it to
1:16:44
do rewriting sets so we're going to see how we can do url rewriting in our
1:16:49
application gateway thanks for watching and i'm going to see you in the next video
Auto Scaling & Zone Redundancy
1:16:58
hi everyone in this video we are going to talk about auto scaling and zone redundancy in our
1:17:04
application gateway so let's go to the configuration tab and as you can see here we have two
1:17:11
capacity types whether it's manual or auto scaling for manual
1:17:16
we have currently two instances for our application gateway and this is actually the recommended
1:17:23
capacity or instance counts to have for production workloads why is that
1:17:29
because we usually create our application gateway to work as a load balancer for maybe 10 or 20 backend
1:17:36
targets and we want to avoid having our application gateway to be a single point
1:17:41
of failure for our architecture because when our application gateway starts to
1:17:47
get so much traffic it might affect its availability and then it's going to be a
1:17:52
single point of failure that could bring your whole architecture down
1:17:57
not to mention that there are some issues might happen in the availability zones where the application gateway is
1:18:03
hosted which is again is going to affect your architecture so as a rule of thumb
1:18:09
it's good to have as a minimum two instance counts for your production workloads for non-production workloads
1:18:16
it's okay to have just one instance counts
1:18:22
now let's have a look at the auto scale port in the auto scaling for our application
1:18:27
gateway you will get to specify the minimum instance count and the maximum
1:18:32
instance count for the application gateway and we all know how auto scaling works
1:18:38
at any point of time our application gateway instances will never go below
1:18:44
the minimum instance count we have is specified which is 2. at the same time the application gateway
1:18:51
instances will never go above the maximum instance count we have specified
1:18:56
here which is 10. by the way let's have a look at the maximum instance count we could have
1:19:03
for our application gateway as you can see here it's 125 for standard version 2
1:19:09
and it would be a little bit less for version 1. anyway let's bring it back to 10.
1:19:15
now let's have a look at the minimum instance count for auto scaling because it's really interesting as you can see
1:19:22
here you can have minimum instance count set to zero for auto scaling
1:19:27
it doesn't mean that you are not going to have any application gateway instances but it means that you are not
1:19:34
going to have additional instances or reserved capacity for your application gateway
1:19:40
although you can set the minimum instance count to zero in the auto scaling settings
1:19:46
you are not able to do the same for manual for a manual capacity type then minimum
1:19:51
in instance count has to be one for your application gateway this is just a little difference between
1:19:58
manual and auto scaling capacity types for your application gateway
1:20:05
now i'm not going to save these changes and let's go ahead and create
1:20:11
a application gateway i'm not actually going to create it i'm just going to show you something for the zone
1:20:18
redundancy because it's available only when you create the application gateway and if you want to change it later on
1:20:25
you can change it using the command line as your command line as you can see here we have a standard
1:20:32
version 2 when we enable auto scaling you will be able to set the minimum number of instances and the maximum
1:20:39
number of instances and as you can see in this tool tip here zero instance count
1:20:45
means that there is no additional reserved capacity for your application gateway however high availability is
1:20:52
still going to be maintained for your application gateway
1:20:57
and the interesting thing that you will get to specify when you create your application gateway is to specify the
1:21:03
different availability zones where you are going to create or launch different instances for your application gateway
1:21:11
ideally you want to deploy it in more than one availability zone this is to ensure that your architecture
1:21:18
will be resilient and solid for any sudden changes that might happen in different azure availability zones
1:21:25
also keep in mind that you when you create a new instance it usually takes five to seven minutes until it takes
1:21:32
place and it's going to be a downtime for your application gateway
1:21:37
also it's important to mention that when we create a new instance it usually takes between five to seven minutes
1:21:44
until it's completed and if you don't want this to have any downtime for your application gateway
1:21:51
what you can do is to configure your application gateway to have a minimum instance count set to two ideally in
1:21:59
different availability zones as well and as i've already said before it's
1:22:04
really recommended for production workloads to have as a minimum two instance counts for your application
1:22:11
gateway and each application gateway instance can support around 10 capacity units and
1:22:18
we are going to understand more what does it mean in the monitoring section when we get to it that's all i have for
1:22:25
you for the auto scaling and zone redundancy now let's go ahead and clean things up
1:22:30
let's delete the resource group and the resources we have been using for the last few videos
1:22:37
so let's go to australia east resource group and let's go ahead and delete it
1:22:43
this is going to delete the application gateway the three vms we had created in
1:22:48
addition to the log analytics workspace thanks for watching and we'll see you in
1:22:54
the next video hi everyone
SSL Introduction
1:23:00
in this section we are going to talk about the application gateway security or to be more specific the ssl security
1:23:09
so in the next few videos we are going to see how can we implement ssl
1:23:14
termination for the application gateway and if you have more stringent security requirements we are going to see how can
1:23:21
you implement end-to-end ssl encryption through the application gateway
1:23:27
finally we are gonna see how can we implement the mutual authentication and configure
1:23:33
the right ssl policies for your application gateway let's dive straight into it thanks for
1:23:39
watching and i'll see you in the next video
SSL Termination
1:23:46
hi everyone in this video we are going to talk about ssl termination on the
1:23:51
application gateway but firstly let's talk a little bit about what ssl traffic termination means
1:23:59
let's look at this diagram here let's assume that the users are interacting with the application gateway using https
1:24:07
which is secured by ssl certificate and has ssl encryption on that traffic
1:24:14
and what's going to happen in the case of ssl termination that the application gateway is going to decrypt that traffic
1:24:22
and then we'll continue the communication with the rest of the back in the targets unencrypted over http
1:24:30
this is what ssl termination means and i hear some of you are asking why do
1:24:35
we need to do this why do we need to unencrypt the traffic at the application gateway side
1:24:42
and continue the traffic unencrypted with the rest of the back in the targets
1:24:48
and there are four main benefits for doing the ssl traffic termination at the
1:24:53
application gateway side first of all it improved the performance for your architecture let's agree on something
1:25:00
the biggest performance challenge any server would experience in when the server is trying to do the ssl
1:25:07
decryption this is why you will see that the server is going to store or save that
1:25:13
decryption values into the cache for future use and what's going to happen when we do
1:25:19
the ssl termination at the application gateway then the application gateway is going to
1:25:24
store the decryption into the cache to be used in future communications with a particular client
1:25:32
but if we have done the ssl decryption at the backend servers then every time
1:25:37
the client is going to send the request reaching to the back in the targets then the backing the targets will have to
1:25:44
re-authenticate which is going to impact the overall performance of your architecture
1:25:50
and this is the first point for using the ssl termination at the application gateway
1:25:56
and the second benefit is you are going to have a better utilization on the backend targets
1:26:03
because you are going to move or off load so the speak the ssl decryption
1:26:08
from the back and the targets to the application gateway leaving the backend targets with more
1:26:14
resources to do its main tasks also the third benefit you are going to
1:26:20
get in here when we decrypt the traffic at the application gateway side you are
1:26:25
going to have more visibility on the request content like request headers uri
1:26:31
and so on and this will allow the application gateway to do more intelligent routing to other backend
1:26:37
targets finally and more importantly which has an operational lens which is the
1:26:43
certificate management it's going to be much easier for you to manage the certificates the ssl certificates at the
1:26:51
application gateway side rather than have to manage them at all
1:26:56
back in the targets you have in your architecture so this is just a briefly to tell you
1:27:01
why do we need to use ssl termination in some scenarios however
1:27:06
some security agencies or some government agencies will have some requirements to use end-to-end
1:27:13
encryption between the client and the backend targets and in this case you will have to use end-to-end ssl
1:27:21
encryption which you are going to talk about in more details in the next video
1:27:26
now after we understood what ssl traffic termination means and what are the
1:27:31
benefits of it let's get back to azure portal and start creating our resource
1:27:38
group to see how this work let's call it
1:27:43
australia east resource group and let's put it on australia east
1:27:49
region let's go ahead and create it then go into the application gateways
1:27:55
let's go ahead and create one put it in australia east resource group
1:28:01
call it my application gateway put it in australia east region no auto scaling
1:28:07
and put it in our v-net that you have created and in the application gateway
1:28:12
subnet moving to the front-end parts let's go ahead and create a public ip address for the application gateway
1:28:23
let's go to the back end let's create a back in the pool let's call it my back and pull
1:28:29
and let's make it empty pool going to the configurations let's add a
1:28:35
routing rule let's call it my routing rule
1:28:41
and then the listener let's call it my listener select our public ip address
1:28:48
and then let's select the back in the target select my back in the pool and let's create http settings let's call it
1:28:55
http settings and let's go ahead and add the routing rule
1:29:00
and then let's go ahead and create our application gateway as you already know it takes about few
1:29:07
minutes for the application gateway to be ready so let's go ahead and create a new virtual machine that we are going to
1:29:14
use in this scenario so i'm going to create a new virtual machine
1:29:21
did an australia east resource group i'm gonna call it contoso vm [Music]
1:29:27
and then i'm gonna put a username and password for the vm no inbound ports are gonna be open
1:29:34
and then going to the networking i'm going to put it in the v-net that we have created before and in the default
1:29:41
subnet let's go ahead and create our vm
1:29:47
all right now my vm is ready let's go ahead and open a windows powershell as
1:29:53
an administrator to create a self-assigned certificate and let's run these commands that i'm
1:30:00
going to leave in the description box
1:30:06
then let's copy the thumbprint that we have got from the first command
1:30:11
and put it in the second command here to get the pfx certificates
1:30:23
right and let's go ahead with that now we have created the certificate
1:30:29
now let's have a look at the listeners now if you remember when we created the listener we have created http listener
1:30:37
which is actually is not going to work what we need to do is to create https listener
1:30:43
and as you can see here there is no option for me to change the listener type from http to https
1:30:51
what you can do instead is to go ahead and create a new listener let's call it ssl listener
1:30:58
and then it's going to be on the public ip address and then let's select https
1:31:03
and then in this case i will have to upload a certificate whether to upload it from a key vault or upload it from my
1:31:10
machine so i'm going to call it application gateway certificate and then the pfx file that we have
1:31:17
created using the powershell window and then putting the password for the
1:31:22
certificate which was one two three four let's leave the ssl profile for now we
1:31:29
are gonna come back to it in a bit now let's add this listener
1:31:35
now i will need to update the routing rules and everything in my application gateway to listen to the new listener
1:31:42
that we have created so in my routing rule i'm going to update it to listen to the ssl listener
1:31:49
and then it's going to route the traffic to my backend pool and if you notice here the http settings are going to
1:31:56
remain http settings we don't need https settings if you remember
1:32:03
we are doing ssl traffic termination so we are terminating the traffic after
1:32:08
the application gateway receives it and then we aim to continue the traffic unencrypted with
1:32:15
other backend targets so in this case we only have to use http settings
1:32:22
for the routing rules we don't need https settings
1:32:27
now getting back to our application gateway and let's save our changes
1:32:32
and now i'm gonna go ahead and update the back in the pool and select the vm
1:32:39
as a backend target let's go ahead and save our changes
1:32:46
and while we're waiting for this let's go ahead and install iis
1:32:52
on contoso vm that we have created so we can perform our test let's open a new
1:32:57
cloud shell terminal and let's run this command to uninstall
1:33:03
iis on contoso vm
1:33:09
so i'm going to change the vm name in here let's go ahead with that
1:33:17
alright now i have everything set up now let's go
1:33:24
now let's go ahead and test it let's copy the public ip address of my application gateway put it in the
1:33:30
address bar as you can see it didn't get us anything because we
1:33:36
have used http to hit the ip address of our application gateway which is not
1:33:42
linked to any routing rules and if i'm going to change it to https
1:33:47
instead of http then we are going to see that my antivirus shows that it's a
1:33:54
self-assigned certificate and it shows me a warning so i'm gonna go ahead with i'm wishing to continue
1:34:02
as you can see here it directed us to contoso vm this is to show you how we can have an
1:34:08
encrypted traffic communication between the client and the application gateway and then we
1:34:15
decrypt it at the application gateway and continue the traffic unencrypted
1:34:20
with the back in the targets this is what we call ssl termination
1:34:26
that's all i have for you in this video however i'm not going to delete the application gateway yet because we are
1:34:33
going to use it in the next few videos thanks for watching and we'll see you in
1:34:38
the next video hi everyone in this video we are going to see how we
End-to-End SSL Encryption
1:34:45
can do an end-to-end ssl encryption through the application gateway just to
1:34:51
recap on the previous video we have seen how the users can send encrypted traffic
1:34:57
to the application gateway and then the application gateway is going to decrypt
1:35:02
the traffic by doing ssl termination at the application gateway and continue
1:35:08
that traffic unencrypted to the backend targets now we are going to do end to end
1:35:15
encryption which means all the communication between the users to the back in the target has to be encrypted
1:35:23
and actually what's going to happen not quite different from the first scenario so when the application gateway receives
1:35:30
an encrypted request from the users what's going to happen is that the application gateway is going to decrypt
1:35:37
the traffic again even though it's an end to end ssl encryption scenario
1:35:43
so the application gateway is going to decrypt the request coming from the user
1:35:48
so the application gateway can really see what's inside the request to be able to route it to the right back in the
1:35:55
target and then what's going to happen and this is the main difference between the ssl
1:36:00
termination scenario and end-to-end scenario so what's going to happen in the
1:36:05
end-to-end ssl encryption scenario is that the application gateway is going to
1:36:11
initiate a new ssl connection between the application gateway and the back in
1:36:16
the targets the application gateway is going to initiate the new ssl connection using an
1:36:23
https settings that we are going to define in the application gateway
1:36:28
these https settings are using the backend target certificates this is will
1:36:34
allow the application gateway to initiate a new ssl connection between
1:36:40
the application gateway and between the back and the targets and any response from the back in the
1:36:46
targets are going to follow the same approach going to the application gateway and then going back to the user
1:36:55
this is how we can do end-to-end ssl encryption through the application
1:37:00
gateway so it's primarily the main thing that we will need to do now is just to go ahead
1:37:06
and create https settings and provide the back-end target certificates into
1:37:11
those settings to have end-to-end ssl encryption through the application
1:37:17
gateway so let's go ahead to the azure portal and see how can we do this
1:37:22
so this is my application gateway and let's go to http settings i have already
1:37:28
created http settings let's go ahead and create
1:37:33
settings let's call it ssl settings
1:37:38
and again the back end of protocol in this case is going to be https as you can see here in this case i need
1:37:45
to provide a certificate file and if you have tools like openssl you can use it
1:37:51
to get your cer file for your back in the targets however i'm not going to do this for this video and
1:37:58
let's go ahead with a well-known ca certificates however it's not going to work at the end i'm just showing you the
1:38:05
steps and then let's leave everything to the default values and let's save our
1:38:10
changes so now by creating this new ssl settings
1:38:15
that are using https connection between the application gateway and the back in the targets this is going to ensure that
1:38:23
we are going to implement an end-to-end ssl encryption between the users going
1:38:29
through the application gateway and then ending up to the backend targets
1:38:34
that's all i have for you in this video thanks for watching and we'll see you in the next video
Mutual Authentication & SSL Policies
1:38:43
hi everyone in this video we are going to see how we can do mutual authentication between the
1:38:49
client and the application gateway but firstly let's understand what mutual
1:38:54
authentication means in the previous scenarios we have seen how the application gateway could
1:39:00
authenticate the requests coming from the client and the mutual authentication will allow
1:39:07
both the client and application gateway to authenticate each other which is
1:39:12
really recommended these days with the increase of iot use case scenarios and
1:39:18
the increased security requirements for some agencies so how can we do the mutual
1:39:24
authentication in the application gateway simply we go to ssl settings and
1:39:29
let's create a new ssl profile so i'm going to call it ssl profile
1:39:35
and in here you will have to upload your certificate whether it's cer or pim file
1:39:41
however i'm not going to do this and then you are going to specify the ssl policy and let's select the
1:39:47
predefined one and go ahead with the default let's go ahead and add the ssl profile
1:39:55
then what i would need to do is to link this ssl profile with my listener so i'm
1:40:00
going to go to listeners to ssl listener and then i'm going to enable ssl profile and in here i would be able
1:40:08
to select the profile i have created with the right certificate and the right ssl policies
1:40:17
now let's get back to the ssl policies to have a deeper look into it
1:40:24
so looking at the ssl policies here you have two options to choose from whether
1:40:30
to select a predefined policies which is the recommended in most cases whether you create a custom one
1:40:37
and if you choose a predefined one it's going to be more easier for you and it lists to you here the minimum protocols
1:40:44
and ciphers that are allowed in this ssl policy and if you decided to choose the
1:40:50
custom option then you will have to specify the minimum tls version to go for whether it's 1 1.1 or 1.2 and then
1:40:59
you are going to select each of the cipher protocols that you want to select for your ssl profile
1:41:06
that's all i have for you for the ssl profile and mutual authentication in the application gateway
1:41:12
and i think at that point we have covered everything i want to cover in the ssl section regarding the
1:41:20
application gateway maybe the only thing that i need to mention here is how do you manage the certificates for your
1:41:27
application gateway and backend servers and the clients maybe you should consider using an azure key vault to
1:41:33
have all of your certificates in one place it's going to make it easier for you to manage easier for you to maintain
1:41:40
and upgrade and also it's going to be much less operational overhead on you on your
1:41:45
teams now i'm gonna go ahead and delete the application gateway probably the whole
1:41:51
resource group all together so let's go to australia east resource
1:41:56
group and let's delete the resource group
1:42:03
thanks for watching and i will see you in the next video
AKS Ingress Controller Introduction
1:42:09
hi everyone in this section we are going to talk about the aks integration with the
1:42:15
application gateway of course everyone knows aks stands for azure copy native services
1:42:22
and we are going to talk about the green field implementation and the brown field implementation so in the green field
1:42:28
implementation we are going to deploy a brand new application gateway along with
1:42:33
aeks cluster and we are going to see how the ingress controller is going to work
1:42:39
and for the brownfield implementation we are going to reconfigure an existing application gateway with a new aks
1:42:47
cluster and we are going to see what will be the required changes we will do for the application gateway to be able
1:42:54
to route the traffic to aks cluster let's dive straight into it
1:43:00
and i'll see you in the next video hi everyone in this video we are going
Ingress Controller for AKS (Greenfield)
1:43:08
to talk about ingress controller add-on for aks and we are going to do this by a green
1:43:14
field deployment and what i mean by greenfield we are going to deploy a brand new aks cluster
1:43:21
as long as with a brand new application gateway cluster and then we are going to see how both are going to
1:43:27
talk to each other to route the traffic from the application gateway to aks
1:43:33
application that we are going to deploy let's get started by creating a resource
1:43:40
group and let's call it australia east
1:43:46
resource group
1:43:52
and let's put it in australia east region and let's go ahead and create it
1:43:58
now let's open a cloud shell terminal
1:44:09
and let's paste this command that is going to install application gateway as well as copernitus cluster aks cluster
1:44:18
let's go ahead with that
1:44:25
all right now let's run this command to get the cluster credentials
1:44:37
and finally let's deploy a sample application on our aks cluster so we can test it through our application gateway
1:44:49
all right everything is now set up for us let's go to our application gateway and see what is the public ip address of
1:44:55
our application gateway but you might have noticed that the application gateway is still updating
1:45:03
because once we run the first command to install the application gateway and the aks cluster the application gateway
1:45:10
setup hasn't finished yet so we need to wait a little bit of time until the application gateway deployment is done
1:45:18
and then we can test our application gateway or the public ip address of our application gateway and at that point it
1:45:25
will redirect us to the sample application that we just deployed on the aks cluster
1:45:34
all right now my application gateway is ready let's copy the public ip address of my
1:45:40
application gateway and put it in the address bar and test it
1:45:49
as you can see here it opens the sample application that we have deployed in our aks cluster this is just to show you how
1:45:57
we can use the application gateway to route traffic to another backend service or back in the target and in this case
1:46:04
it was aks and if you go back to the application gateway you will be able to see that the
1:46:11
command that we run at the first place have already created the back in the targets http settings and the listeners
1:46:18
and routing rules that will allow the application gateway to direct the traffic to the back end target aks
1:46:28
and this is why we call it a green field deployment everything it's going to be deployed brand new deployment whether
1:46:35
it's aks cluster or the application gateway now let's go ahead and clean things up
1:46:43
let's go to the resource groups and i'm going to delete australia east resource group
1:46:57
and also there is another resource group has been created for the cluster
1:47:03
let's go ahead and delete it as well
1:47:11
that's all i have for you for this video and in the next video we are going to see how we are going to use aks cluster
1:47:18
with an existing application gateway and that's what we call it a brown field deployment
1:47:24
thanks for watching and we'll see you in the next video
Ingress Controller for AKS (Brownfield)
1:47:30
hi everyone in this video we are going to see the ingress controller for aks through a
1:47:36
brown field deployment like we are going to have an application gateway already created for us
1:47:43
and then we are going to create an aks cluster then we are going to see how we can let both of them talk to each other
1:47:50
we are going to have to create a v-net peering between the two v-nets that
1:47:56
application gateway and the aks cluster is hosted and also to do some other
1:48:01
configurations in the aks cluster so let's get started by creating a
1:48:07
resource group
1:48:13
and let's call it australia east resource group let's put it in australia east region
1:48:21
and let's go ahead and create it now let me open a cloud shell terminal
1:48:26
and let's go ahead and run this command that is going to install aks cluster
1:48:33
into our subscription
1:48:40
however if you notice here this time we are not going to have an application gateway compared to the last command we
1:48:47
ran in the previous video let's go ahead with that
1:48:52
and while our cluster is being created let's go ahead and create an application gateway
1:49:03
let's put it in australia east resource group and let's call it my application gateway
1:49:09
put it in australia east region no auto scaling and let's put it in the
1:49:15
v-net we have created before and in the application gateway subnet
1:49:21
now let's go to the front end let's create a new public ip address let's call it ip
1:49:28
application gateway and then let's go to the backend pool
1:49:33
and let's go ahead and add one let's call it my back-end pool
1:49:38
and no target so far now let's go to the configuration tab
1:49:45
and let's go ahead and add a routing rule let's call it
1:49:50
routing rule and let's put a listener
1:49:56
and let's select the public ip address of our application gateway and for the back in the targets let's select my back
1:50:03
in the pool let's go ahead and create http settings my http
1:50:10
settings and let's go ahead and add the routing rule
1:50:17
now let's go ahead and create our application gateway
1:50:29
all right now let's go ahead and run this command to get our cluster credentials
1:50:35
i'm gonna change the resource group here to be our resource group australia east
1:50:44
and let's go ahead with that
1:50:49
all right now let's run our last command to install a sample application on our
1:50:57
cluster let's go ahead with that
1:51:03
all right so we have everything ready for us now so let's go to the aks cluster
1:51:10
and let's see how we are going to link both together the application gateway
1:51:15
and the aks cluster let's browse to networking and at the end here we are
1:51:21
going to see application gateway in grass controller and let's go ahead and enable it
1:51:27
then you are going to choose whether to create a new application gateway or to choose an existing one
1:51:33
so we are going to use our application gateway that we have already created to just show you how it's going to work
1:51:41
and this is what we mean by the brownfield deployments as you can see here i have got an error
1:51:47
because there is an overlap between the address space in both v nets
1:51:53
what does this mean so let's go to the v nets
1:52:02
as you can see here this is the v-net that i've created the first place
1:52:07
it has addresses space 10.0 to zero cider range 16
1:52:13
and this is a new v-net that has been created for the cluster and as you can see the address space is
1:52:20
10 0 0 0 8
1:52:25
and as long as there is an overlap between these two v nets i can't make
1:52:30
appearing connection between them so what i am going to do now is to go ahead and change the address space of
1:52:37
the v-net that's been created for my copper needs cluster because it's really
1:52:42
too big so let's go to the address space but before that let me check the
1:52:49
address space for our copper native subnet probably i'm gonna copy it over
1:52:56
and put it in the address bar for the subnet for the v-net
1:53:02
and let's go ahead and save our changes
1:53:10
now let's get back to my cluster and go into the networking
1:53:19
select again application gateway and grass controller and select our application gateway you
1:53:25
will see that there is no errors anymore let's go ahead and save our changes
1:53:34
all right now the ingress controller has been completed for my cluster let's go back
1:53:41
to the application gateway and see how this changed as you can see here
1:53:47
we can read that one of the backend targets are not reachable or not healthy
1:53:53
receiving 502 error we are going to come back to this in a bit but going to the back in the pools you
1:53:59
will be able to see here another back in the pool has been created with a new
1:54:04
target which links our application gateway to the aks cluster that we have
1:54:10
created so this has been done when we enabled the ingress controller for the
1:54:15
application gateway in our aks cluster now let's get back to the error that we
1:54:22
have just seen 502 error one of our backend pools are not healthy why is
1:54:28
that remember when i said at the beginning that we will need to have a v-net peering between both v-nets given that
1:54:37
we have our aks cluster in one v-net and our application gateway in another
1:54:43
v-net they can't see each other and what we need to do now is to link or have a
1:54:48
v-net peering between these two v-nets let's go ahead and do this
1:54:54
go to peering and let's add v-net peering let's call it peering source
1:55:02
and call the remote one peering remote and then let's select the cluster been
1:55:08
appearing and go ahead with that now the vein appearing has been created
1:55:16
between the two v-nets just wait few seconds until it's been established and
1:55:21
then we can go ahead and test reach to our application through the
1:55:26
application gateway all right now the v-net p-ring has been
1:55:33
connected between the two v-nets let's go back to my application gateway
1:55:40
and we still see this warning anyway i'm gonna copy the public ip address of my application gateway and go ahead with
1:55:48
that as you can see we have been able to open the
1:55:53
web app or asp.net app from our application gateway in a brownfield
1:55:59
deployment although each of the application gateway and the aks cluster has been deployed to a
1:56:06
different v-net we have been able to connect to both of them by using v-net peering
1:56:14
that's all i have for you in this video now i'm going to go ahead and clean
1:56:20
things up let's go to resource group and let's delete our resource groups
1:56:33
and then delete the other resource group that has our cluster
1:56:44
thanks for watching and i will see you in the next video
Web Application Firewall (WAF)
1:56:50
hi everyone in this video we are going to see how can we create a web application firewall
1:56:56
for our application gateway so in the previous videos if you remember we have always created a
1:57:02
standard tier for our application gateway and in this video we are going to create
1:57:08
a waf tier for our application gateway let's get started and head to the
1:57:13
application gateway and let's create one i'm going to put it in australia east
1:57:19
resource group and call it wealth and i'm going to host it in australia
1:57:25
east region and in that here here i am going to select wav version 2
1:57:31
and no auto scaling is required and you may notice the difference here
1:57:37
when i've selected wav version 2 that you have to choose the firewall
1:57:42
status whether it's enabled or disabled also it's mode whether it's detection
1:57:48
only or prevention so i'm going to leave it to the default values with enabling the firewall with
1:57:54
detection mode also when i selected wav version 2 i
1:58:00
will be able to choose which availability zones to host or deploy my application gateway or my wealth
1:58:08
http 2 is going to be disabled and i'm going to put it in australia east
1:58:14
v net we have created before and in the subnet we have created for the
1:58:19
application gateway and let's move to the next step
1:58:24
and i'm going to create a public ip address and i'm going to call it ipwef
1:58:31
let's go to the backend and i'm going to create a back in the pool
1:58:38
with no targets and then for the routing rules i'm going
1:58:45
to create a routing rule
1:58:50
to send the traffic from the public ip address of my application gateway
1:58:56
to the back in the pool i have created let's go ahead and create http settings
1:59:02
as well and let's add our routing rule
1:59:07
now let's go ahead and create our application gateway
1:59:14
all right the application gateway now has been created so let's go to the application gateways
1:59:21
and browse to waff and as you can see here a new menu item for web application
1:59:26
firewall and there are different configurations you can change and save your changes
1:59:31
accordingly so in here you are able to see some global parameters like the maximum
1:59:38
request body size you can specify it in the web application firewall settings in
1:59:44
addition to the file upload limit as well if you want to put some restrictions on the size of the files
1:59:50
that are going to go through the application gateway let's go ahead and have a look at the
1:59:56
rules as well as you can see here the rule set has been selected to be wasp 3
2:00:03
however we are going to see how we are going to change or play around with these rules in a bit
2:00:10
now let's go ahead and create a web application firewall policy and there is a reason they put it
2:00:16
separate from the application gateway so let's go ahead and create a new web
2:00:24
application firewall policy as you can see here you can specify or create this policy either for global
2:00:31
wave like a front door or a regional wave application gateway or azure cdn
2:00:39
and it's still in preview so i'm going to go ahead and create a policy for our application gateway
2:00:46
and i'm going to put it in australia east resource group i'm going to call it waf
2:00:52
policy in australia east policy state is enabled and detection mode
2:01:01
now moving to the next step you are going to specify the rule set you are going to use for the web
2:01:08
application firewall policy as you can see here we have selected oasp 3.1
2:01:14
because 3.2 is still in preview and while you are creating the valve
2:01:20
policy you have the ability to choose from what are the policies you are going to
2:01:26
enable or disable on your web application firewall policy
2:01:32
so these are the different policies that are applicable for oasp 3.1 and you can
2:01:38
choose any of these policies and go ahead and disable it if you want so when
2:01:43
you create your web application firewall policy you have more freedom and flexibility to disable which policies
2:01:50
are not going to work for your organization or which rules are not going to work for your security settings
2:01:59
however we are going to keep everything to the default values and then let's go to the next page
2:02:05
this is where we are going to specify our policy settings and we have seen something similar in the application
2:02:12
gateway itself where you specify the maximum request body size and the
2:02:17
maximum file upload size as well then moving to the custom rules let's
2:02:23
add a new custom rules and see what's in there i'm going to call it rule 1
2:02:28
and i'm going to give it a priority 1. so we have a condition here if the ju location
2:02:36
is coming from a request header called the location and it's not equal to australia
2:02:44
then we are going to deny the traffic so this is just a custom role we have created in our web application firewall
2:02:52
to block any traffic coming outside of australia
2:02:57
let's go ahead and add it then move into the association so in this page you are able to
2:03:03
associate your policy with either application gateway or http lessener
2:03:10
so let's try to do the both let's go for the http listener
2:03:15
and we are going to choose the waf we have created and we have a listener we
2:03:20
have created for our wife if you remember and also i'm gonna go ahead and
2:03:26
associate our policy with our application gateway we have created and
2:03:31
as you can see here we have got a warning that our application gateway
2:03:36
has already a wealth policy and if we associated the new policy we are creating to our application gateway it's
2:03:44
going to override these changes so i'm going to go ahead with that
2:03:49
and i'm going to add our application gateway as well
2:03:55
and now let's go ahead and create our wav policy
2:04:03
all right now our wef policy has been created so let's head straight to it and
2:04:09
in here you will be able to manage your policy settings and your managed rules as we have created wasp 3.1 and also the
2:04:17
custom role that we have created to block any traffic coming outside from
2:04:22
australia and you are able to see the associated gateways as well application gateways we have associated it to the
2:04:30
whole gateway instance in addition to a specific listener for the application
2:04:36
gateway that's all i have for you in this video now i'm gonna go ahead and clean things
2:04:41
up so i'm going to delete the waff application gateway i have created
2:04:47
before all right now my application gateway has
2:04:52
been deleted let's go ahead and delete the waf policy i've created before
2:05:01
that's all i have for you in this video thanks for watching and i'll see you in the next video
Monitoring Introduction
2:05:10
hi everyone in this section we are going to see how can we monitor our application gateway by configuring
2:05:17
diagnostic settings and we are going to see what are the important metrics that you need to keep an eye on to ensure
2:05:23
that your application gateway is functioning well and also we will see how can we set up
2:05:29
some alert rules so you are going to get notified if the selected metrics have
2:05:34
exceeded a certain threshold then we are gonna see how can we use the log analytics workspace to see more
2:05:42
details about our application gateway routings and finally we are going to see the
2:05:47
healthy probes and how can we use it to determine the back end health of our application gateway
2:05:54
that's all i have for you in this video it's an introductory video to give you a bit of information about the next few
2:06:01
videos let's dive straight into it thanks for watching and i will see you in the next video
Diagnostic Settings
2:06:09
hi everyone in this video we are going to talk about the diagnostic settings for the
2:06:14
application gateway so let's get started and go to the application gateway i've created and
2:06:21
let's scroll down to diagnostic settings
2:06:26
as you can see here when you go ahead and create diagnostic settings you will have an option to choose from different
2:06:33
log categories obviously first i need to put the name my settings
2:06:39
and in here you are going to see different log categories and we're going gonna go through them one by one quickly
2:06:46
the first look category we have in here is the access log application gateway access log
2:06:52
which allows you to see the access patterns for your application gateway allows you to see the caller ip address
2:06:59
requested url response latency return code by its in and out from your
2:07:05
application gateway and the access logs are collected every 60 seconds
2:07:12
and coming to the second category we have here is the performance log which allows you to see how your application
2:07:19
gateway instances are performing using the performance logs you will be able to see different information
2:07:26
like total requests being surveyed by your application gateway and the total throughput in bytes total requests
2:07:33
served failed request counts and the number of healthy and unhealthy back-end
2:07:39
instance counts as well all of these things are going to be collected every 60 seconds in the
2:07:45
performance log and finally we have the firewall log which shows you the different prevention
2:07:52
mode of your application gateway whether you set it for detection mode or prevention mode you are going to see all
2:07:59
of this information in the firewall logs and similar as before firewall logs are
2:08:05
collected every 60 seconds so i'm going to go ahead and select all logs and all metrics
2:08:12
and i'm going to send all of these data to a log analytics workspace obviously i need to go ahead and create
2:08:20
one so let's create log analytics workspace
2:08:32
and i'm going to put it in australia east resource group and i'm gonna call it
2:08:37
my log analytics workspace
2:08:44
and i'm going to put it in australia east region
2:08:51
and let's go ahead and create my log analytics workspace
2:09:01
all right now my log analytics workspace is ready let's go back to the application gateway
2:09:08
and let's refresh this page
2:09:14
so i'm gonna create or add a new diagnostic settings i'm gonna call it my settings
2:09:20
selecting all logs all metrics and send them to the log analytics workspace i
2:09:26
have just created and i'm gonna go ahead and save my changes
2:09:37
as you can see here my diagnostic settings has been applied to the application gateway that's all i have
2:09:43
for you in this video thanks for watching and i'm gonna see you in the next video
Metrics
2:09:52
hi everyone in this video we are going to talk about the application gateway matrix
2:09:58
and you can go to the application gateway matrix by browsing to the monitoring section and head straight to
2:10:04
matrix then you will be able to see the different metrics that are available for
2:10:10
you in the application gateway and even better you can apply even some filtering on the selected metrics
2:10:18
however there is another way to view application gateway metrics which i really prefer unlike
2:10:24
so i'm gonna go to insights instead and then i'm gonna click on view detailed
2:10:30
metrics which is going to view the same application gateway metrics we have seen
2:10:35
before however it puts it in a different graphical representation and puts them
2:10:41
under different categories which is going to make more sense to you before we dive deep into it let's talk a
2:10:48
little bit more about the key metrics for your application gateway starting with the unhealthy host count
2:10:55
and this is the count of the backend instances that are unhealthy based on the health probe that you have defined
2:11:02
for your application gateway and we are going to talk about the health probe in
2:11:07
a little bit having the field requests counts which
2:11:12
is the count of the field number of requests and in application gateway version 2 this is the number of 500
2:11:20
response codes been returned from your application gateway
2:11:25
then you have the current capacity units which is an interesting one we are going to see in more details in here in the
2:11:32
performance section but briefly it combines the three different metrics or
2:11:37
dimensions current compute units and throughput and current connections
2:11:44
now let's dive deep into the performance category to see what are the different metrics that are available for us to use
2:11:51
in the performance category first metrics we have in here is the
2:11:56
capacity units and as you can see per description here it's been determined by three dimensions compute unit
2:12:04
current connections and throughput and just below it you will be able to
2:12:10
see more detailed information about the three metrics like in here you will be
2:12:15
able to see more information about the compute units and the compute unit simply is the
2:12:21
processing power required from the application gateway to do certain actions like url rewriting or header
2:12:29
rewriting or ssl connection encryption decryption or maybe applying a waf rule
2:12:35
on the application gateway all of these things comes under compute units
2:12:41
then we have the current connections which is measured by the number of concurrent connections between the
2:12:48
clients and the application gateway then we have the throughput which is the
2:12:55
average byte per second processed by the application gateway these three metrics contributes to the
2:13:03
overall results you are going to see in the capacity units for the application
2:13:08
gateway and at the bottom here you are going to be able to see the number of bytes sent
2:13:14
from the application gateway and the numbers of bytes received from the application gateway
2:13:21
those are the key metrics that are going to help you to determine how your application gateway is performing
2:13:30
now moving on to the second category of metrics which is the latency matrix and this is very very important to
2:13:36
understand what are the key differences between some of these metrics
2:13:42
so in the first graph here we have a combination of the application gateway total time
2:13:48
versus the backend last byte response time let's first understand what is the
2:13:53
difference between both and to help you understand this better i'm gonna refer you to this graph here
2:14:00
so this is the application gateway total time which is the interval between when the
2:14:07
application gateway received the request from the client till the application gateway sends the
2:14:14
last response to the client it's like an end-to-end journey from
2:14:19
receiving request to responding with a response however for the back end the last byte
2:14:25
response time this is the interval between when the application gateway received the request from the client
2:14:33
till the application gateway received the last response from the back in the
2:14:38
target so we have a gap in here to understand
2:14:44
how much time been required from the application gateway to be able to send
2:14:50
all response to the client so this is a key benefit from having this graph here and having both of these
2:14:57
metrics in one graph so for example as we can see in here the
2:15:03
application gateway total time is pretty stable which is the blue dotted line
2:15:08
however the back end the last byte response time had a spike
2:15:14
which means the backend required some time until it finishes sending all of
2:15:19
the responses to the application gateway which is okay sometimes if we didn't
2:15:25
have enough cash for the back end the targets however if this graph two lines
2:15:30
has been reverted like if we had a spike in the application gateway total time
2:15:37
and the back in the last byte response time was stable that would suggest that
2:15:42
we have a bottleneck in the application gateway or in the networking part between the client and the application
2:15:49
gateway getting back to the graph here if we had a spike in the total time here
2:15:55
means that the application gateway took too much time until it forwarded the
2:16:00
responses it received from the back in the target to the client
2:16:05
which you might suggest that you need to launch an additional application gateway instances or maybe improve the
2:16:12
networking between the client and your application gateway however it's not
2:16:18
going to be a decision you are going to decide based on this matrix only but you
2:16:23
are going to look at the other metrics to see how you can overcome this challenge
2:16:30
now moving to the second graph we have here which combines three key metrics
2:16:35
first one is the back end connect time second one is the back end first byte
2:16:40
response time and the third one backend last byte response time
2:16:47
let's look at the graph to understand what is the difference between these three metrics
2:16:53
so the backend connect time just the time that it talk to establish a
2:16:59
connection between the application gateway and the backend targets as simple as that
2:17:05
and the back in the first byte response time is the interval between when the
2:17:10
application gateway sends or is started to establish a connection with the backend targets till
2:17:18
the application gateway started to receive the first response from the backend targets
2:17:24
while the back in the last byte response time is the interval between when the application gateway started to establish
2:17:32
a connection with the back in the target until the application gateway received
2:17:38
the last response from the back in the target having the three metrics in one graph
2:17:43
will help you to understand more where the latency is at whether it's in the backend server side or whether it's in
2:17:50
the application gateway side so let's get back to our graph
2:17:56
now looking at our graph here and try to analyze it a little bit what will happen if we have a spike in the back in the
2:18:03
first byte response time that might suggest that the backend server talk too
2:18:08
much time until it started to send the responses to the application gateway and
2:18:14
in this case the backend server might be the reason of the latency for our graph
2:18:22
however if we had a spike in the back and the last bite response time that might suggest that the backend
2:18:30
response is too big that took too much time until it completely finished sending the full
2:18:37
response to the application gateway again these are the different scenarios
2:18:42
that are going to help you to understand where the latency is at whether it is in
2:18:48
the application gateway or whether it is in the backend server
2:18:55
so these are the different things you need to be aware of in the latency matrix now moving to the traffic matrix
2:19:03
which is going to show you the total number of requests coming through to your application gateway and the number
2:19:09
of failed requests and as you can see here the number of field requests are exactly the number of 500 response codes
2:19:17
received by applications gateway and also you are able to see the different
2:19:22
numbers across different response code categories 400s 300s and 200s
2:19:30
and also at the end here you are going to see the number of requests been received for different tls versions
2:19:36
whether it's 1 1.1 or 1.2
2:19:42
now moving on to the backend metrics which is quite important to keep them
2:19:47
side to side with the application gateway metrics because sometimes when you get an error
2:19:53
you can't decide whether the error in the application gateway itself or actually the error in the backend
2:20:00
server and you need to do something about it so having these two metrics next to each
2:20:06
other the application gateway metrics and the backend metrics are going to help you a lot to determine where is the
2:20:13
problem and how you are going to solve it the first metrics we have here is the healthy host count which tells you how
2:20:21
many healthy hosts you have in your application gateway according to the
2:20:26
health probe configurations that we are going to talk about in the next video in a future video maybe not the next one
2:20:34
and then you have the unhealthy host counts as well that we have talked about at the beginning and then you have the
2:20:39
different response codes received from the back and the servers
2:20:45
interesting point here is that there is zero response code received under 500
2:20:51
category however in the previous screen we had 10 failed requests under 500 response code
2:20:58
category that would tell you that the 500 response code is caused by the
2:21:04
application gateway not from the backend server because here at the backend server there is no 500 response code has
2:21:13
been returned from the backend target and for the billing metrics there is an
2:21:19
estimated build capacity units which is measured by consumption based and there
2:21:25
is a fixed cost as well which you are able to see in these graphs here
2:21:30
these are the most important metrics that you need to be aware of for your application gateway
2:21:36
and trust me it's going to help you to troubleshoot and diagnose and know where exactly the issue is at in your
2:21:43
application gateway and this is not the end of the journey for the metrics so in the next video we
2:21:50
are going to see how we are going to set alerts to notify you when some of the metrics exceeded a certain threshold
2:21:58
that you are going to specify according to your requirements in your organization
2:22:03
that's all i have for you for this video thanks for watching and i'm going to see you in the next video
Alerts
2:22:12
hi everyone in this video we are going to talk about alerts in the application gateway
2:22:19
if you remember in the previous video we have talked about the metrics and how the metrics will give you some
2:22:25
visibility on what's going on in your application gateway it will allow you to
2:22:30
see where is the problem and what is the problem in your application gateway
2:22:35
and definitely you are not going to be looking at the metrics screen 24 7 so you can detect if
2:22:42
something wrong happen with your application gateway so we want to have some kind of automation that are going
2:22:49
to tell you or notify you if a certain matrix has gone beyond or below a
2:22:54
certain threshold that you are going to define and this is exactly what the alerts are doing so let's go ahead to our
2:23:02
application gateway and let's create an alert
2:23:07
so i'm gonna go ahead and create an alert rule i'm gonna make it on
2:23:12
a specific metric let's call it field requests and if you remember the
2:23:19
failed requests are the number of 500 response codes that our application
2:23:24
gateway has responded with so it's going to be a good indication for us to know if there is any faults in
2:23:31
our application gateway and selecting a dimension name here for
2:23:37
our metric and i'm going to select all current and future values
2:23:42
because if i've selected it for that current back in the pool and i updated the application gateway
2:23:48
adding more back-end pools for future probably the new back-end pools are not
2:23:54
going to be included in this alert rule so by selecting all current and future
2:23:59
values is going to ensure that for all future back in the polls i might add to
2:24:05
my application gateway they still are going to be evaluated by this alert rule
2:24:12
now when it comes to the alert threshold we have two options whether to choose the static or dynamic
2:24:20
and it's a pretty simple and straightforward where we are going to define the threshold value for our
2:24:26
alerts so if we have got more than 10 500 response codes
2:24:31
over a five minutes period then the alert is going to trigger and notify us that there is something
2:24:38
wrong in our application gateway and also you can have a dynamic alert type
2:24:44
by specifying the threshold sensitivity whether it's high medium or low
2:24:49
and for this case if it's a 500 error you want to make the sensitivity is high
2:24:55
because it's not very common for your application gateway to start responding with 500 response codes
2:25:02
and you want to be notified straight away when your application gateway started to respond with 500 response
2:25:09
codes so i'm going to save my changes
2:25:15
and then moving to the actions here you can add an action group or create an action group let's go ahead and create
2:25:22
an action group let's call it action group
2:25:29
and the notification type here you are going to specify whether you are going to notify a group of people based on
2:25:36
these options whether you can notify them by email or sms or push notification or voice
2:25:43
however i'm going to leave it empty for now but you can put the email addresses for the people that needs to be notified
2:25:50
when this alert is triggered then coming to the actions here you can specify what is the action type you want
2:25:57
to do when this trigger when this alert is triggered maybe you can specify an
2:26:02
azure functions app that is going to do some remediation actions that are going to bring everything back to normal or
2:26:11
you can select any of these services to do any of the remediation action when the alert is triggered
2:26:18
let's go ahead and create the action group we have a missing action here okay let's delete it because i am not going
2:26:24
to specify a functions app
2:26:31
now getting back to our alert rule and let's go ahead and create it
2:26:36
again we are missing one step here in the details the name of our rule
2:26:44
i'm gonna call it my alert rule and then let's go ahead and create it
2:26:49
and as you can see here you are going to pay a little bit of money when you create an alert and so you need to be
2:26:55
very careful on the frequency how you are going to evaluate this alert rule because it might add more money on your
2:27:03
monthly bill so let's go ahead and create the alert rule
2:27:08
and from here you can go to manage alert rules so you can go ahead and play around with the alert rules you have
2:27:15
created for the application gateway and also you will be able to view the action groups in a separate view in here
2:27:24
now let's go ahead and clean things up i'm going to delete the action group and getting back to the alert rule
2:27:31
and delete our alert rule as well
2:27:37
that's all i have for you for this video thanks for watching and i will see you in the next video
Log Analytics
2:27:45
hi everyone in this video we are going to talk about the log analytics in the application
2:27:51
gateway so let's go to our application gateway
2:28:00
and let's scroll down to the logs but if you remember
2:28:05
previously in the diagnostic settings video we have set up diagnostic settings
2:28:11
to our application gateway so let's go ahead and review this quickly so we have configured our diagnostic
2:28:18
settings for the application gateway to send all logs access logs performance logs and
2:28:24
firewall logs in addition to the metrics to the application to the log analytics
2:28:30
workspace we have created before if you want to know the difference between these different categories of
2:28:36
logs i recommend you to revisit the diagnostic settings video for the
2:28:42
application gateways so after we have set up our diagnostic
2:28:47
settings to send these different kind of logs to the log analytics workspace we
2:28:53
will be able to see or view different logs in the logs section here in our
2:28:59
application gateway and as you can see here there are predefined the queries already you can
2:29:05
use straight away to tells you what are the different status in your application gateway
2:29:11
so probably i'm gonna go ahead and run errors by uri query and see what kind of
2:29:17
results we are gonna be getting and as you can see here for the last 24
2:29:22
hours the query shows me the aggregated values of the requested uris that's been
2:29:29
through the application gateway so i would suggest you to go through the
2:29:34
different queries that you will be able to see for your application gateway and be
2:29:39
familiar with them so you are going to use them if you want to troubleshoot or diagnose a certain situation and if you
2:29:46
remember we have used the log analytics workspace to see how the the url rewriting took place in
2:29:55
our application gateway and it's one of the previous videos we have done if you remember
2:30:00
now one important thing you need to be aware of let's go to the log analytics
2:30:05
workspace let's select my log analytics workspace
2:30:12
and let's go to usage and estimated coast and as you can see here there are
2:30:18
two important options data retention so in this you are going to specify for
2:30:24
how long you want to retain the data in the log analytics workspace the minimum
2:30:30
value is 30 days maximum value is for 730 and you cannot choose
2:30:37
how long you want to retain the data for your log analytics workspace
2:30:42
and for the daily cap here you are going to specify how much of the daily data
2:30:47
are allowed to be ingested into your log analytics workspace and as you can see here there is a
2:30:54
little bit of cost estimations based on the daily ingested volumes for your log
2:31:00
analytics workspace it's going to give you a clue of how much is going to cost you at the end of the month
2:31:07
just be careful this is not the actual or estimated cost that i'm going to pay by the end of the month this is based on
2:31:14
100 gigs per day commitment tier not the actual estimated price that i am
2:31:21
going to pay based on my current usage just be aware of that
2:31:28
that's all i have for you for the log analytics workspace and how you can use it to get more information
2:31:34
for your application gateway thanks for watching and i'll see you in the next video
Health Probe & Backend Health
2:31:42
hi everyone in this video we are going to talk about the back end health and the healthy
2:31:48
probes in the application gateway so let's scroll down to the back end health
2:31:53
and see what we are going to get as you can see here we have got a
2:31:59
healthy back-end target for our application gateway so this is the back-end vm we have linked to our
2:32:06
application gateway over http traffic on port 80 and the response was 200
2:32:13
response code and the back end the target is healthy so when we create our application
2:32:19
gateway and link it to abec and the target the application gateway automatically is going to configure a
2:32:26
default health probe i'm going to use it to test the health of the backend targets that are linked
2:32:33
to the application gateway and the application gateway is going to use the http settings we have configured
2:32:41
to connect to the backend target or a back-end server to test whether the
2:32:46
back-end server is healthy or not and the default health probe is going to
2:32:51
be triggered every 30 seconds to ensure that our backend server is
2:32:56
healthy so who is going to use this information we are going to use this information
2:33:03
from the azure portal to know the health of the backend servers also the application gateway is going to
2:33:10
use this information to know the healthy status of the backend servers
2:33:16
so if the application gateway determined an unhealthy backend server
2:33:21
what the application gateway is going to do is to stop sending traffic to the
2:33:27
unhealthy server until it became healthy again and the default health the probe is
2:33:34
going to be run every 30 seconds so the application gateway continuously
2:33:39
monitoring the health of your backend vm servers
2:33:44
so where are the default health probes are configured actually you cannot see it you can't edit it they are just being
2:33:52
used based on the http settings you have configured to connect to your backend vm
2:33:58
targets and the default health the probes are going to be used by the application
2:34:04
gateway as long as you haven't configured or defined a custom healthy
2:34:10
probe so what is the custom health probe so if you go to healthy props in here
2:34:16
and let's go ahead and create a custom healthy probe let's call it custom health probe
2:34:23
and here we are going to define how the application gateway is going to do the healthy check with the back-end server
2:34:31
so i'm going to put the ip address of my vm and then the path here backslash
2:34:37
and what's interesting in the custom health probes you get to define the interval in seconds the default is 30
2:34:45
seconds as i said before in the default healthy probe but you can
2:34:50
configure it to be much less than that or much longer than that based on your
2:34:55
situation and also you get to define the timeout and the unhealthy threshold
2:35:02
also you get to choose the http settings that the application gateway health
2:35:08
probe is going to use to perform the test or monitoring the health of the
2:35:13
back end vm so let's go ahead and test our custom healthy probe before we start adding it
2:35:21
as you can see here our back in the pool our backend vm is healthy let's go ahead
2:35:27
and add the healthy probe and let's go back to the back end health
2:35:32
and see what will be the result we will be getting after we defined a custom
2:35:37
health probe and as you can see here our backend dvm is healthy however in this case
2:35:44
our application gateway used the custom healthy probe we have used
2:35:50
because we have created a custom healthy probe that is stopped the application gateway from using the default health
2:35:57
probe so how many tests the back-end vm will be receiving
2:36:04
as i said before the default health probe will send a test signal to the
2:36:09
back in the vm every 30 seconds so if we have one application gateway
2:36:16
and one lessener and one vm at the back end so the backend vm is going to get a test signal
2:36:24
every 30 seconds but what if we have two listeners on the
2:36:29
application gateway side both listeners pointing to the same vm
2:36:35
then the vm is going to receive two test signals every 30 seconds
2:36:41
one for each listeners all right now what if we have two
2:36:47
application gateway instances and each of them has two listeners
2:36:52
pointing to the same vm then the target vm is going to receive four test signals every 30 seconds
2:37:01
two signals for each application gateway instance and in each application gateway instance
2:37:07
there are two signals are going to be sent for each listener this is just to help you understand how
2:37:14
the application gateway continuously monitoring the health of the back and
2:37:19
the targets now i'm gonna go ahead and delete the custom healthy probe that i have created
2:37:28
and that's all i have for you in this video thanks for watching and i'm going to see you in the next
2:37:34
video hi everyone in this section we are going to talk
Advanced Topics Introduction
2:37:40
about the advanced topics of the application gateway like how can you configure your application gateway to be
2:37:47
able to support high traffic coming through your application gateway then we are going to talk about some
2:37:53
topics like cookie affinity connection draining what is the pricing model of the application gateway and the
2:38:00
different tiers as well let's dive straight into it and i'll see you in the next video
High Traffic Support
2:38:10
hi everyone in this video we are going to talk about the high traffic support for the
2:38:15
application gateway so whether you are using your application gateway as a standard load
2:38:22
balancer or as a wealth in most cases you are going to have a
2:38:27
bunch of vms or app services or back in the targets to direct the traffic to
2:38:33
them and most probably you are going to have some auto scaling plans for those
2:38:39
backing the targets to make sure that you are going to be scaling up and down based on the traffic
2:38:45
you are receiving and the last thing you want to do is to create a bottleneck for your
2:38:51
architecture by creating one application gateway in instance to receive all
2:38:57
traffic coming from the users it's going to be too much load on one
2:39:02
application gateway instance to direct the traffic to all back in the targets
2:39:08
so you have done a really good job by creating a scaling plans for the back and the targets
2:39:14
at the same time i don't want you to forget about the scaling plans for the
2:39:20
application gateway itself and if you have seen the auto scaling and zone redundancy videos you might get
2:39:27
the answer straight away like we can create auto scaling plans for the application gateway as well
2:39:34
which is absolutely true so i'm going to head to the configuration here and
2:39:39
change the capacity type to o2 scaling
2:39:44
so i have two options now to choose the maximum instance count and the minimum instance counts
2:39:51
and since i have version 2 i can have up to 125 instances for my application
2:39:58
gateway and this is the maximum number of instances i can have for my application gateway
2:40:04
and let's assume that the peak load for my application gateway requires only 50
2:40:11
instances 5 0 and it wouldn't be a problem by specifying the maximum instance count
2:40:18
too high because again i have created enough buffer in case of my application
2:40:24
gateway started to get unexpected traffic but when it comes to specifying the
2:40:31
minimum instance count it can be too tricky because if i specified five instances
2:40:37
only then it might be a problem or another bottleneck in the architecture
2:40:43
i haven't mentioned that it takes a few minutes for the auto scaling activities to take place usually
2:40:51
between six seven minutes for the new application gateway instances to be
2:40:56
provisioned and to be able to process the traffic and for those few minutes you
2:41:03
don't want to strain or put extra effort or extra pressure on the existing
2:41:09
application gateway instances so that's why it's very important when you specify
2:41:14
the minimum instance count is to aim for a reasonable number so we assumed already that our peak load
2:41:22
requires 50 application gateway instances and in this case for the minimum instance count would be
2:41:29
25 a good number even better to aim for 30 application gateway instances as a
2:41:36
minimum instance count this is going to ensure that you have an enough number of application gateway
2:41:43
instances to handle the normal traffic and also to handle the increase the
2:41:49
traffic that you might get till the auto scaling activities took place
2:41:55
definitely i'm not going to save my changes i don't want azure to go ahead and create 30 application gateway
2:42:02
instances for me and you don't want to do this as well so i'm going to discard my changes
2:42:10
now i'm going to show you another way to determine the minimum instance count for the application gateway
2:42:16
so let's head straight to the metrics i'm going to show you a metric you can look at
2:42:23
i'm going to go to compute units metric and if you have this metric over one
2:42:29
month it will give you a good idea about what could be the minimum number of instances you should have for your auto
2:42:37
scaling plans be aware that this scale is divided by 10
2:42:42
and also note that one application gateway in instance can handle a minimum of 10 compute units
2:42:50
now let's go back to the scaling
2:42:55
what if you don't want to do auto scaling some companies have certain requirements
2:43:02
that actually is not going to fit in the auto scaling plans or probably they just
2:43:07
want to create a manual scaling for their environment so they know exactly
2:43:12
when it goes up and when it goes down and in this case there is no minimum or
2:43:17
maximum instance count we can specify here we just have one number we need to
2:43:23
put and getting back to the previous example that our peak load requires 50
2:43:29
application gateway instances if we put this number in the instance
2:43:35
counts for the application gateway here again it's going to be a bottleneck for
2:43:40
the architecture because there is no room to handle any unexpected traffic that might come
2:43:47
through the application gateway so as a rule of thumb if your peak workload is
2:43:52
50 instances then you should aim to have 55
2:43:58
or 60 instances for your application gateway
2:44:03
if you decided to go ahead with the manual scaling
2:44:08
however my recommendation for you is to use auto scaling as long as it will meet
2:44:14
your requirements you don't want to set up manual scaling unless you really want to
2:44:20
now i'm going to discard my changes a very important part to support high
2:44:28
scaling in the application gateway to set up few alerts that keep an eye on a
2:44:33
few metrics that are really key to support high traffic through the application gateway
2:44:40
and what i'm going to do now is to go ahead and create these sets of alerts that you should set up for your
2:44:46
application gateway to keep an eye on its capacity utilization error rates etc
2:44:53
so let's go ahead to alerts i'm gonna go ahead and create an alert
2:44:58
rule for compute unit metrics
2:45:05
and i'm going to specify the threshold value like above it it's going to notify
2:45:12
me that something is wrong with the application gateway so i'm going to specify 7.5 because this
2:45:19
scale is divided by 10 so 7.5 reflects to 75 percent of the compute utilization
2:45:27
of the application gateway instances so this is going to be the first alert
2:45:33
that i need to create i'm going to call it
2:45:39
compute alert
2:45:44
second alert that i need to create is for capacity utilization current
2:45:51
capacity units and same as before i should aim for 75
2:45:59
and again for the details i'm gonna put capacity alert as a name
2:46:07
and i'm gonna go ahead and create the alert rule also you need to keep an eye on
2:46:13
unhealthy instance counts so let's select unhealthy host counts metrics
2:46:21
because this gives us a good indication on the number of unhealthy back-end
2:46:26
targets we have in the application gateway so i'm going to put a random
2:46:31
threshold value here let's say 10 however you should aim to put an accurate number for your use case
2:46:39
and in the dimensions here i'm going to select all back-end pools i have in the
2:46:44
application gateway current and futures let's go ahead and add this alert again
2:46:52
unhealthy alert
2:46:59
also you should create an alert to keep an eye on the response code status
2:47:04
whether you're receiving 400 500 through your application gateway so it's going
2:47:10
to be a really good alert to keep an eye on so for the dimensions here i'm going
2:47:15
to select 400 and 500 categories and if the number exceeds
2:47:21
a certain threshold like 20 for example then this alert is going to be triggered
2:47:27
and in the details here i'm going to put a name response alert for example
2:47:35
also you want to create an alert for the field requests
2:47:42
as we've already known that field request primarily reports the 500 response code for the application
2:47:49
gateway and i'm going to select the back in the pool in here current and future and the threshold value
2:47:57
also one of the important or useful metrics or alerts you could set up is to
2:48:03
keep an eye on the 400 response codes because usually it tells you that
2:48:08
someone might be trying to attack your application gateway and you are going to see this in a bit
2:48:15
i'm going to call this failed alerts let's go ahead and create this alert
2:48:24
when your application gateway responds with 400 response code that means
2:48:30
whether the user is unauthenticated or unauthorized or maybe someone
2:48:35
trying to getting through your application gateway if you started to get hundreds or maybe
2:48:40
thousands of these 400 errors over one minute it might be a good indicator that
2:48:47
you are under tech and you should set up this alert as well like having a response code
2:48:53
response is tedious here to be for 400 only
2:49:00
and if you received more than 500
2:49:06
for example that might be a good indication that you are under attack
2:49:11
again let's put authentication alert
2:49:18
let's create this alert as well
2:49:24
then i'm gonna go ahead and create two more alerts to give us more indication about the performance and how our
2:49:31
application gateway responds to the requests from the application gateway side and from the back end as well
2:49:39
so i'm going to choose another metric last byte back in the last byte response time
2:49:47
and probably for this one i'm going to choose the back in the pool as the target and
2:49:54
i'm going to choose all current and future values and for this one let's keep it static
2:50:00
the threshold value let's say whatever one millisecond or whatever
2:50:05
you wanna you wanna put and then let's go ahead and add this alert
2:50:10
let's put a name first and then here we are gonna call it
2:50:16
back end last byte alert and then let's go ahead and create this
2:50:22
alert and finally the last alert i'm going to create is for the application gateway
2:50:28
total time this is again to help us understand if there is any latency issue in our
2:50:35
application gateway or in the back end the targets i'm gonna specify a value here to be
2:50:42
five for example and selecting a specific listener for the application
2:50:49
gateway i'm going to select all current and future listeners
2:50:54
let's go to the details and put in a name let's call it total
2:51:01
time alert let's go ahead and create this alert
2:51:11
so these are the different kind of alerts that you should set up for your application gateway
2:51:17
in order to keep an eye on the high traffic support for the application gateway instances
2:51:23
this is not to say that other metrics are not important we are focusing here on high traffic support for the
2:51:29
application gateway and we selected the right metrics that are going to be useful for us for this scenario
2:51:37
now i'm going to go ahead and delete all of these alert rules i have created
2:51:50
and that's all i have for you in this video thanks for watching and i will see you in the next video
Pricing
2:51:58
hi everyone in this video we are going to talk about the pricing of the application gateway before we get
2:52:06
started it's important to mention that the numbers you are going to see in this video are just used for illustration
2:52:13
purposes only they are not an actual numbers and to get the exact numbers for your
2:52:20
region head to the pricing page or as your calculator when it comes to the application gateway
2:52:27
pricing the most important thing i want you to be aware of is that there are two
2:52:33
parts of application gateway cost there is a fixed cost you are going to pay even if
2:52:39
you have zero instances for the application gateway as long as you have created application gateway on the azure
2:52:46
portal you are going to pay this fixed cost also there is a capacity unit cost which
2:52:53
we call sometimes variable costs and these two adds up to be the total cost
2:52:59
that you will have to pay at the end of the month for your application gateway usage
2:53:06
and i think you already know that a partial hour usage is going to be billed as a full hour
2:53:12
like if you have used your application gateway for 10 minutes you are going to get it charged as if you have used it
2:53:20
for one hour now let's look at these fixed cost and variable cost pricing for different
2:53:26
tiers as you can see here the cost per hour is different for different tiers
2:53:32
standard is way cheaper than waff tier for the application gateway and
2:53:37
similarly for the capacity unit for the standard and the wav tier as well
2:53:43
also i want you to keep in mind something that outbound the data transfer if you are going to send the
2:53:49
data outside of the azure region where the application gateway is hosted there
2:53:55
is additional charge you are going to pay for the outbound data transfers
2:54:01
now let's have a look at this example here to help us understand how the pricing works
2:54:07
let's assume that you have used your application gateway with manual scaling and you set it for eight instances and
2:54:14
you used it for a month so based on that for the fixed price
2:54:20
it's going to be for the full month it's going to be 179 dollars
2:54:25
however for the variable cost so we have eight instances each instance have thin
2:54:31
capacity units and we are going to multiply it for the number of hours we have per month
2:54:36
and again ending up with 467 adding these two values the fixed cost
2:54:43
and the variable cost it's going to be the total cost that you'll have to pay at the end of the month for your
2:54:50
application gateway usage and i'm going to put a link for this webpage in the description box
2:54:57
as there are other examples you can go through to understand how the pricing
2:55:02
how the calculation works for the application gateway and as you have mentioned before in the
2:55:08
metrics there are few metrics you can use to understand or to see or set some
2:55:14
alerts for the application gateway whether for the fixed capacity units or for the estimated capacity units
2:55:22
that's all i have for you in this video thanks for watching and i will see you in the next video
Cookie-Affinity
2:55:29
hi everyone in this video we are going to talk about the cookie affinity for the application
2:55:35
gateway and you can configure it in the http settings for your application
2:55:41
gateway simply the cookie affinity is a way to maintain user sessions so when the user
2:55:47
sends their first request to the application gateway what's going to happen is that the application gateway
2:55:53
is going to forward or route that request to a specific backend server
2:55:59
and then what we want to achieve here is when the user sends a subsequent
2:56:04
requests to the application gateways we want the application gateway to send
2:56:09
those requests to the same server where the user had the session opened before
2:56:15
this is what we call its session stickiness sometimes and we are able to achieve this by having a hash value in
2:56:21
the response with the session details so when the user sends future requests to
2:56:27
the application gateway the application gateway will be able to determine what was the backend server that that user
2:56:35
session is stored on it however if your backend servers cannot
2:56:40
handle cookie affinity then you cannot use this feature obviously
2:56:46
also for more complex scenarios or more high availability scenarios some people
2:56:51
would prefer to have the user sessions stored on an external cache
2:56:57
like redis or maybe on cozonusdb to have the user sessions maintained outside of
2:57:03
the backend servers completely this is just to give you an idea what is the cookie affinity is about and how you
2:57:11
can set it up let's look at the http settings in here you can enable cookie
2:57:17
affinity from the http settings in the application gateway that's all i have
2:57:22
for you for this video thanks for watching and i'll see you in the next video
Connection Draining
2:57:30
hi everyone in this video we are going to talk about connection training which is a really
2:57:36
useful feature for the application gateway so connection draining simply is going to remove the back and the pool
2:57:43
target from receiving the future requests and this happens when the back in the target is going through some
2:57:50
planned service updates definitely the application gateway is not going to terminate the existing
2:57:57
connections with a particular back-end target however what's going to happen is
2:58:02
that the application gateway is going to maintain the existing connections however it's not going to open any new
2:58:09
connection requests with the back in the targets and there is one exception in here if we
2:58:15
have the cookie-based affinity is enabled then the application gateway will continue to forward the traffic to
2:58:23
the de-registered instances also i want you to be aware that the connection training also applies to the backend
2:58:30
instances that are explicitly removed from the back end pool so i believe the cookie affinity and
2:58:37
connection draining are really useful features for the application gateway and you should use them for your use case
2:58:44
that's all i have for you in this video thanks for watching and i'll see you in the next video
Custom Error Pages
2:58:52
hi everyone in this video we are going to talk about the custom error pages for the
2:58:58
application gateways so we already seen what's gonna happen when
2:59:03
the application gateway cannot reach to one of the back in the targets the application gateway is going to respond
2:59:10
with 502 bad gateway response code to the end user
2:59:16
and what the custom error pages is going to do is to provide your own branding and own layout
2:59:23
to the end user so you are going to have a better user experience for the end customer
2:59:28
and there are different scenarios in which you want to implement a custom error pages for your application gateway
2:59:35
when you have a maintenance scenario like some of your back in the targets are not available for any reason and if
2:59:42
the user will be trying to hit these back in the targets going to receive 502
2:59:48
bad gateway response or maybe the user is trying to access some pages that the
2:59:54
user is not authorized to access them so these are the two main scenarios for the
3:00:01
custom error pages it's going to be useful if you have your own brand and a custom layout to make a good user
3:00:07
experience with the end customer and when it comes to creating the custom error pages you could create either a
3:00:15
global custom error page that would apply on the whole application gateway instance
3:00:22
or you could create a custom error page on a specific listener or you could apply them on both
3:00:28
however when it comes to the global custom error page it's not supported through the azure portal yet what i'm
3:00:35
gonna do i'm gonna refer you to this webpage and i'm going to put a link to it in the description box so you can use
3:00:42
azure powershell to create a global custom error page for your whole application gateway instance
3:00:50
however what i'm going to show you now is how to create a custom error page on a listener so i'm going to go to
3:00:56
listeners and then in the listeners here you're able to see error page url and if i'm going to click
3:01:04
on yes in this case you'll need to specify two different urls it's gonna be
3:01:10
htm or html file extensions for the bad gateway response code 502 and for
3:01:17
forbidden 403 response code and then you will be able to apply the
3:01:23
custom error page on that listener that's all i have for you for this video
3:01:28
thanks for watching and i'm going to see you in the next video
Web Sockets Support
3:01:35
hi everyone in this video we are going to talk about application gateway support for web sockets
3:01:43
websockets are going to be very useful in fast time sensitive applications like
3:01:49
game applications dashboards or a chat application
3:01:54
and the reason for the websockets it's very fast and reliable because it operates at tcp connection so at first
3:02:02
the client does a hand the check with the web server through http connection
3:02:08
and once the hand check is completed then the connection is going to be upgraded from http to tcp which is going
3:02:15
to be more faster and reliable than http or https
3:02:23
and actually to allow a websocket communication there is nothing different you are going to do from the application
3:02:29
gateway because you can have a websocket communication over http or https
3:02:36
settings in the application gateway just wanna make sure that you're back in the target is supporting web socket
3:02:43
communications that's all you have to do and then you will be able to have web sockets communication in the application
3:02:50
gateway that's all i have for you for the web sockets thanks for watching and
3:02:55
i'll see you in the next video
Application Gatewat Tiers
3:03:01
hi everyone in this video we are going to talk about the different features in different
3:03:07
application gateway versions version 1 versus version two and i'm
3:03:12
going to put a link for this webpage in the description box as you can see in this table here auto
3:03:19
scaling zone redundancy static ip address are not supported in version one
3:03:25
similar to ingress controller for aks key vault integration and http
3:03:31
re-writing and these are important things that you need to be aware of upfront before you make your decision
3:03:39
and going ahead with purchasing or allocating application gateway version one or
3:03:45
version two if you would need any of these features in your application gateway then probably it's gonna be a
3:03:52
better choice if you go ahead with version 2 from the beginning
3:03:57
also be aware of that application gateway version 2 is not currently available in few regions so please make
3:04:05
sure you check that before you provision your application gateway version 2 in any of these regions
3:04:12
and if you currently have application gateway version 1 and you want to migrate it to version 2 however you can
3:04:19
follow this walkthrough here so you can upgrade or migrate your application
3:04:24
gateway from version one to version two that's all i have for you for the
3:04:30
different tiers of the application gateway and what are the different features between version 1 and version
3:04:36
2. thanks for watching and i will see you in the next video
Configurations Introduction
3:04:43
hi everyone in this section we are going to talk about the application gateway configuration
3:04:49
and most importantly the infrastructure configuration like the v-net and the subnet configurations that you need to
3:04:56
be aware of and plan ahead before you create your application gateway then we are going to jump into the other
3:05:02
configurations on the application gateway itself like the ip addresses different listeners routing rules http
3:05:10
settings ending up to the backend pools let's dive straight into it
3:05:16
and i'll see you in the next video hi everyone
Infrastructure
3:05:22
in this video we are going to talk about the infrastructure requirements for the application gateway
3:05:29
as any azure service application gateway needs to be deployed in an azure v-net
3:05:35
and in azure subnet there is no difference in here but when it comes to azure subnets there
3:05:42
are few things you need to be aware of and it's going to be better if you plan ahead how you are going to have the size
3:05:49
of your subnet that you are going to deploy the application gateway in it
3:05:54
first thing you need to know that azure reserve is 5 ip addresses in every
3:05:59
subnet you create in azure the first four ip addresses and the last ip
3:06:05
address so if you are going to plan to have 15 application gateway instances in a
3:06:12
certain subnet you wanna add the five reserved ip addresses by azure so you are gonna end
3:06:19
up having 20 ip addresses for your subnets five are going to be used by azure and
3:06:26
the 15 are going to be used by the application gateway instances
3:06:31
and if you apply the same thinking and if you want to deploy 27 application gateway in instances
3:06:38
by adding up the five ip addresses reserved by azure then you are going to
3:06:43
end up having a 33 ip addresses required to be free and available in your subnet
3:06:51
so generally speaking when you want to deploy application gateway version 1 or waff version 1. both of them can support
3:06:59
up to 32 instances so it's gonna be better if you design your subnet having
3:07:04
a 26 insider range for the subnet this is going to ensure you are going to have
3:07:10
enough addresses space in your subnet so you can scale your application gateway instances in future if you want to
3:07:18
however when it comes to application gateway version 2 or waffle version 2 both can support up to 125 instances
3:07:27
and it's recommended to have subnets with a cider range to 24. again this is
3:07:32
going to allow more address space in your subnet to allow more room for
3:07:37
scalability these are just a general information you need to be aware of when it comes to the
3:07:43
subnets where you are going to deploy your application gateway
3:07:49
and there is a bit of a subnet dedication is required as well like you cannot deploy any other
3:07:56
azure service in the same subnet where you deployed your application gateway
3:08:01
however you can deploy additional application gateway in instances in the same subnet
3:08:07
and you can deploy a new application gateway all together in the same subnet without any problems however you cannot
3:08:14
combine both application gateway version one an application gateway version 2 in
3:08:20
the same subnet both have to be in a separate subnets these are just a few subnet dedications
3:08:27
you need to be aware of when it comes to the application gateway and when it comes to network security
3:08:34
groups you can apply them to the application gateway as well however you need to make sure that you allow the
3:08:40
incoming traffic on these ports for version one and these ports for version two this is to ensure that azure will be
3:08:48
able to route traffic to your application gateway instance and for the outbound internet
3:08:54
connectivity you want to make sure that it's not blocked like you don't remove the default outbound rule or you don't
3:09:01
create any other outbound rule that are going to block the default outbound rule
3:09:07
for the internet connectivity and finally you want to make sure that the traffic coming from azure load balancer
3:09:13
tag to any subnet must be allowed this is all i have for you for the
3:09:20
infrastructure setup for the application gateway and i'm going to put a link for this
3:09:25
webpage in the description box thanks for watching and i will see you in the next video
Front-End IP
3:09:32
hi everyone in this video we are going to talk about the front-end ip addresses
3:09:37
in the application gateway as you already know there are two types of ip addresses available in the application
3:09:44
gateway whether you can have a public ip address or a private ip address or you
3:09:50
can have both however if you want to have only a private ip address for your application
3:09:56
gateway it's only supported for version 1. as you can see here application
3:10:01
gateway version 2 cannot have only a private ip address but it can have both
3:10:07
private and public ip address so you want to use the public ip address
3:10:13
when you design your application gateway to accept traffic coming from the public internet however you want to aim to use
3:10:20
the private ip address if you want to design your application gateway to work as an internal load balancer and
3:10:28
accepted traffic from internal systems or internal components you have deployed
3:10:33
internally in azure so when it comes to the public ip address you can create either a static
3:10:39
or a dynamic ip address and for the private ip address it has to be in the same subnet range we have created before
3:10:48
that's all i have for you for the front-end ip addresses for the application gateway and i'm going to put
3:10:53
a link for this webpage in the description box thanks for watching and i will see you
3:10:59
in the next video hi everyone in this video we are going to see
Listeners
3:11:05
application gateway listeners and we have already created multiple listeners while we created different application
3:11:12
gateways in previous videos so simply the listener is checking for
3:11:18
incoming connection requests for the application gateways on a specific port
3:11:23
ip address and protocol the ip address could be a public or private ip address
3:11:29
for the application gateway and the protocol could be http or https
3:11:35
also http 2 is supported on the application gateway however it is
3:11:40
disabled by default and when it comes to the listener types there are two main types the basic type
3:11:48
and multi-site listener for the basic listener this is when you want all of
3:11:53
the traffic are going to be directed to the public or private ip address of your
3:11:58
application gateway and then according to the routing rules you are going to route them to the right back-end pool
3:12:07
and for the multi-site listener this is when we created a multi-site like
3:12:12
contoso.com and fabricam.com both are hosted on the application gateway and
3:12:18
using the routing rules we had been able to route the traffic to the correct back
3:12:23
in the pool order of processing is very important for version 2 multi-site listeners are
3:12:30
always processed before the basic lessons however this is not the case for version one
3:12:36
where the lesseners are gonna be processed in order and for the supported protocols you can
3:12:43
use for your listeners you can use http or https and we are going to see
3:12:50
different scenarios for ssl termination and end-to-end ssl encryption for your
3:12:56
application gateway and as i said before http 2 is supported
3:13:02
web sockets and custom error pages and we are going to dive deeper into these three features in a future video
3:13:10
that's all i have for you in this video thanks for watching and i will see you in the next video
Routing Rules
3:13:19
hi everyone in this video we are going to talk about application gateway routing rules and we
3:13:25
have already seen it before in previous videos so we are creating the routing rules to
3:13:31
route the traffic from a specific listener to a specific back in the pool
3:13:36
as we have seen before and we have two types of routing rules whether we create
3:13:42
a basic rule to forward all traffic on a specific listener to a specified back in
3:13:48
the pool or we can create a path based routing based on the url that the user is going
3:13:54
to send to the application gateway then the routing rule is going to route the
3:13:59
traffic to the right back-end pool and for the order of processing for the
3:14:05
routing rules they are going to be processed in order and in case there was
3:14:10
a request that matched two or more paths then the first one is going to be
3:14:15
processed and also for the redirection settings you can redirect the traffic and
3:14:22
redirect it to a specific listener or maybe internal website or external
3:14:27
website and also you have an option to rewrite the http headers and the urls
3:14:34
and all of these are going to be covered in more details in separate videos that's all i have for you for the
3:14:40
routing rules thanks for watching and i'm going to see you in the next video
HTTP Settings
3:14:47
hi everyone in this video we are going to talk about the http settings for the application
3:14:53
gateway and we have already seen it before in previous videos in briefly the http settings is the
3:15:01
settings that are going to connect the application gateway with the back and the targets
3:15:07
sometimes you want to have an unencrypted communication between the application gateway and the back in the
3:15:13
targets and sometimes if you have a more stringent security requirements than you want to implement and to end the
3:15:20
security from the client till the back in the target then you want to implement https connection between the application
3:15:28
gateway and the back in the target and there are few options in the http
3:15:35
settings like connection draining cookie affinity which you are going to cover in
3:15:40
more details in a separate video that's all i have for you for the http settings
3:15:45
thanks for watching and i will see you in the next video
BackEnd Pools
3:15:51
hi everyone so throughout this course we have been using the virtual machine as the
3:15:57
back-end the target for our application gateway and i'm sure some of you already are asking what are the different
3:16:03
targets we can have as a back-end pool for the application gateway and in this
3:16:08
video we are going to see what are the different back-end targets we can link to our application gateway so we can
3:16:16
link our application gateway to network interface or virtual machine skill sets and this
3:16:23
is also includes virtual machines or public ip address or private ip
3:16:28
address or fqdn which is fully qualified domain name
3:16:34
or multi-tenant backends such as app service
3:16:39
i want you also to keep in mind that the backend targets doesn't have to be in the same availability sets
3:16:46
like the application gateway can have a virtual machine as a back in the targets while the virtual machine is in a
3:16:53
different cluster or different region or maybe outside azure as long as it's
3:16:59
reachable to the application gateway as long as there is a connection between the application gateway and the vm then
3:17:07
we can link them together and we can make that vm as a backend target for the
3:17:13
application gateway and if you are linking the backend pool to an internal
3:17:18
ip address it has to be in the same vnet where the application gateway is hosted
3:17:24
however if you wish to associate a private ip address that sits outside of the v-net where the
3:17:31
application gateway is hosted then you need to have a win-appearing or vpn
3:17:37
gateway between the v-net where the application gateway is hosted with the other v-net that has the
3:17:43
private ip address as well you can have any vm on-premise as well
3:17:50
as a back in the target for your application gateway as long as they are connected either through azure express
3:17:56
route or vpn tunnel through vpn gateways this is just to give you an idea about
3:18:03
what are the different back-end targets you can have for your application gateway
3:18:08
that's all i have for you in this video thanks for watching and i'm going to see you in the next video